---
title: "bggm-var-investigation"
author: "Bj√∂rn Siepe"
date: "`r Sys.Date()"
output: html_document
---
This document contains code to reproduce simulation study 1. 

```{r}
library(tidyverse)
library(doParallel)
library(parallel)
library(foreach)
library(BGGM)
library(graphicalVAR)
library(cowplot)
library(sysfonts)
source("aux_funs.R")

seed = 2022
set.seed(seed)
```

These are intermediate simulation results with which the main figures of the paper can be reproduced. If you load these results, you can jump to the section titled "IF RESULTS PRELOADED".
```{r}
# Evaluated simulation results for BGGM and GVAR
df_eval_gvar <- readRDS(here::here("output/df_eval_gvar_0705.RDS"))
df_eval_bggm <- readRDS(here::here("output/df_eval_bggm_0705.RDS"))

```




# Simulation study

## Simulation conditions
```{r}
# Simulation conditions
n_ind <- 1000 # number of individuals(so models to create) 
n_tp <- c(50,100,200,400,1000) # number of timepoints
n_postds <- 1000 # number of datasets per condition
seed <- 2022
dgp_names <- c("graph1", "graph2", "graph3", "graph4", "graph5", "graph6")

# Priors
dgp <- c(1,2,3,4,5,6)
rho_sd <- c(0.1, 0.3, 0.5)
beta_sd <- c(0.2, 0.5, 1)
n_tp <- c(50, 100, 200, 400, 1000)  # different number of timepoints
tp_cond <- c(1,2,3,4,5)             # different timepoint conditions
n_iter <- 50000                     # iterations for BGGM

# create grid of simulation conditions
cond_grid <- expand.grid(dgp = dgp,
                         n_tp = tp_cond,
                         rho_prior = rho_sd, 
                         beta_prior = beta_sd)

# Conditions of varying sparsity for graphicalVAR
gamma_ebic <- c(0, 0.5)      # EBIC hyperparameter
lambda <- c(NA, 0)

# Grid for graphicalVAR
cond_grid_gvar <- expand.grid(dgp = dgp,
                         n_tp = tp_cond,
                         gamma_ebic = gamma_ebic,
                         lambda = lambda)

# Load DGPs
l_graphs <- readRDS(here::here("data/l_graphs.RDS"))

```


## Data Generation
```{r}
# Loop across all data-generating processes
set.seed(seed)
before_simraw <- Sys.time()
ncores = 40
cl = makeCluster(ncores)
registerDoParallel(cl)
l_raw <- list()
l_raw$graph6 <- l_raw$graph5 <- l_raw$graph4 <- l_raw$graph3 <- l_raw$graph2 <- l_raw$graph1 <-  list()
for(dgp in dgp_names){
  for(t in seq_along(n_tp)){
  l_raw[[dgp]][[t]] <- list()
  l_raw[[dgp]][[t]] <- sim_raw_parallel(dgp = l_graphs[[dgp]],
                                    n = n_postds,
                                    tp = n_tp[t],
                                    seed = seed,
                                    means = 0,
                                    standardize = TRUE)

}
}


stopCluster(cl)


# saveRDS(l_raw, file = here::here("data/l_raw1000.RDS"))
l_raw <- readRDS(here::here("data/l_raw1000.RDS"))

```

Quick check how long estimation takes on these data:
```{r}
# Check time it takes for certain condition
test <- l_raw[[4]][[3]][1:100]

before <- Sys.time()
l_res <- lapply(test, function(x){
  res <- BGGM::var_estimate(as.data.frame(x$data), iter = 50000)
  return(res)
})
after <- Sys.time() - before

after/100
```


## Estimation

Estimate both graphicalVAR in default settings as well as BGGM with varying priors.
```{r}
# Estimating for each model 
# store BGGM results under "nonselect"
ncores = 50
cl = makeCluster(ncores)
clusterExport(cl = cl, "summarize_post")
registerDoParallel(cl)
l_res_bggm <- list()


# For every condition, apply fitting function for BGGM
for(n in 1:nrow(cond_grid)) {
  dgp_ind <- as.numeric(cond_grid[n, "dgp"])
  tp_ind <- as.numeric(cond_grid[n, "n_tp"])
  r_sd <- as.numeric(cond_grid[n, "rho_prior"])
  b_sd <- as.numeric(cond_grid[n, "beta_prior"])
  print(paste0(nrow(cond_grid)-n, " to go!"))
  l_res_bggm[[n]]  <- fit_var_parallel_merged(l_raw[[dgp_ind]][[tp_ind]],
                          rho_prior = r_sd,
                          beta_prior = b_sd,
                          iterations = n_iter,
                          n = 1000,
                          nds = 1000,
                          seed = seed,
                          get_kappa = FALSE, 
                          summarize_post = TRUE,
                          cred_int = c(0.9, 0.95, 0.99),
                          pruneresults = FALSE,
                          save_files = FALSE,
                          multigroup = FALSE,
                          select = TRUE)
    

  
}
stopCluster(cl)

# Attach the simulation conditions
for(m in 1:nrow(cond_grid)){
  for(i in 1:length(l_res_bggm[[m]])){
    l_res_bggm[[m]][[i]]$sim_cond <- cond_grid[m,]
  }
}

# saveRDS(l_res_bggm, here::here("output/bggm-var-sim-res_2403.Rds"))
# l_res_bggm <- readRDS(here::here("output/bggm-var-sim-res_2403.Rds"))



```

### Fit graphicalVAR

```{r}
ncores = 50
cl = makeCluster(ncores)
clusterExport(cl = cl, "fit_graphicalvar_parallel")
registerDoParallel(cl)
l_res_gvar <- list()
time_before_gvar <- Sys.time()
for(n in 1:nrow(cond_grid_gvar)) {
  dgp_ind <- as.numeric(cond_grid_gvar[n, "dgp"])
  tp_ind <- as.numeric(cond_grid_gvar[n, "n_tp"])
  gamma_ebic <- as.numeric(cond_grid_gvar[n, "gamma_ebic"])
  lambda <- as.numeric(cond_grid_gvar[n, "lambda"])
  print(paste0(nrow(cond_grid_gvar)-n, " to go!"))
  
  # unregularized
  if(!is.na(lambda)){
   l_res_gvar[[n]]  <- fit_graphicalvar_parallel(l_raw[[dgp_ind]][[tp_ind]],
                                                  n = 1000,
                                                  gamma = gamma_ebic,
                                                  nLambda = 50, 
                                                  pruneresults = TRUE, 
                                                  lambda_beta = lambda,
                                                  lambda_kappa = lambda)
                            
  }
  # regularized
  if(is.na(lambda)){
   l_res_gvar[[n]]  <- fit_graphicalvar_parallel(l_raw[[dgp_ind]][[tp_ind]],
                                                 n = 1000,
                                                 gamma = gamma_ebic,
                                                 nLambda = 50, 
                                                 pruneresults = TRUE)
    
  }
    

  
}
stopCluster(cl)

time_after_gvar <- Sys.time() - time_before_gvar


# Attach the simulation conditions
for(m in 1:nrow(cond_grid_gvar)){
  for(i in 1:length(l_res_gvar[[m]])){
    l_res_gvar[[m]][[i]]$sim_cond <- cond_grid_gvar[m,]
  }
}

# saveRDS(l_res_gvar, here::here("output/graphicalvar-sim-res_2403.Rds"))
# l_res_gvar <- readRDS(here::here("output/graphicalvar-sim-res_1703.Rds"))


```

## Evaluation

Evaluate both with and without graph selection.
```{r}
l_res_bggm <- readRDS(here::here("output/bggm-var-sim-res_2403.Rds"))
l_res_gvar <- readRDS(here::here("output/graphicalvar-sim-res_2403.Rds"))
l_graphs <- readRDS(here::here("data/l_graphs.RDS"))


## BGGM
l_eval_bggm <- lapply(l_res_bggm, function(x){
  res <- lapply(x, eval_bggm)
  return(res)
})

# Convert list to useful dataframe
rm(l_res_bggm)
df_eval_bggm <- purrr::flatten(l_eval_bggm)
df_eval_bggm <- dplyr::bind_rows(df_eval_bggm)

# Pivot CIs wider
df_eval_bggm_wide <- df_eval_bggm %>% 
  tidyr::unpack(cols = ci, names_sep = "_") %>% 
  pivot_wider(names_from = ci_ci, 
              values_from = c(ci_sum_cover_beta, ci_sum_cover_pcor,
                              ci_width_beta,ci_width_pcor, ci_true_pos_beta,
                              ci_true_pos_pcor, ci_fal_pos_beta,
                              ci_fal_pos_pcor, ci_true_neg_beta,
                              ci_true_neg_pcor, ci_fal_neg_beta,
                              ci_fal_neg_pcor, ci_sens_beta,
                              ci_sens_pcor, ci_spec_beta, ci_spec_pcor))

df_eval_bggm <- df_eval_bggm_wide

# remove leftovers
rm(df_eval_bggm)
rm(l_eval_bggm)
rm(df_eval_bggm_wide)


## GVAR
l_eval_gvar <- list()
for(i in 1:nrow(cond_grid_gvar)){
  l_eval_gvar[[i]] <- lapply(l_res_gvar[[i]], eval_gvar)
}

# Convert to dataframe
df_eval_gvar <- purrr::flatten(l_eval_gvar)
df_eval_gvar <- dplyr::bind_rows(df_eval_gvar)
rm(l_eval_gvar)

# save evaluations
# saveRDS(df_eval_gvar, here::here("output/df_eval_gvar_0705.RDS"))
# saveRDS(df_eval_bggm, here::here("output/df_eval_bggm_0705.RDS"))
df_eval_gvar <- readRDS(here::here("output/df_eval_gvar_0705.RDS"))
df_eval_bggm <- readRDS(here::here("output/df_eval_bggm_0705.RDS"))

```



# IF RESULTS PRELOADED; START HERE

Summarize results and calculate standard errors for point estimates.
```{r}
# Number of repetitions
n_rep = 1000

## For GVAR
df_eval_gvar_mcse <- df_eval_gvar %>% 
   # pivot_longer, split beta and pcor
    pivot_longer(cols = -c(dgp_ind, tp_ind, lambda, ebic), 
               names_to = c(".value", "mat"), 
               names_pattern = "(.*)_([^_]+)$") %>% 
  dplyr::group_by(dgp_ind, tp_ind, lambda, ebic, mat) %>% 
  dplyr::summarize(
    bias = mean(bias), 
    bias_mcse = sqrt((1/(n_rep*(n_rep-1)))*sum(bias_sq)),  # double check the square here
    cor = mean(cor), 
    cor_mcse = sqrt(1-cor^2)/sqrt(n_rep-2),
    sens = mean(sens), 
    sens_mcse = sqrt((sens * (1-sens))/n_rep),
    spec = mean(spec),
    spec_mcse = sqrt((spec * (1-spec))/n_rep)) %>% 
  ungroup()


## For BGGM
df_eval_bggm_mcse <- df_eval_bggm %>% 
  # pivot_longer, split beta and pcor
  tidyr::pivot_longer(cols = -c(dgp_ind, tp_ind, rho_prior, beta_prior,
                           contains("ci")), 
               names_to = c(".value", "mat"), 
               names_pattern = "(.*)_([^_]+)$") %>% 

  rename(bias_bggm = bias, 
         rmse_bggm = rmse, 
         cor_bggm = cor) %>% 
    pivot_longer(
    cols = c(bias_bggm, # Specify the columns to pivot
             rmse_bggm, 
             cor_bggm, 
             bias_sel, 
             rmse_sel, 
             cor_sel),  
    names_to = c(".value", "method"),  # Specify the new column names
    names_pattern = "(.*)_(.*)"  # Pattern to match the column names
  ) %>% 
  dplyr::group_by(dgp_ind, tp_ind, rho_prior, beta_prior, mat, method) %>% 
  dplyr::summarize(
    bias = mean(bias), 
    bias_mcse = sqrt((1/(n_rep*(n_rep-1)))*sum(bias_sq)),
    cor = mean(cor), 
    cor_mcse = sqrt(1-cor^2)/sqrt(n_rep-2),
    sens = mean(sens), 
    sens_mcse = sqrt((sens * (1-sens))/n_rep),
    spec = mean(spec),
    spec_mcse = sqrt((spec * (1-spec))/n_rep)) %>% 
  ungroup()

```


Combine evaluations of BGGM and graphicalVAR
```{r}
# For joining, select one of the prior conditions
df_eval_both <- df_eval_bggm_mcse %>% 
  # filter(beta_prior == 0.5 & rho_prior == 0.5) %>% 
  left_join(df_eval_gvar_mcse, by = c("dgp_ind", "tp_ind", "mat"),
            suffix = c("_bggm", "_gvar")) %>% 
  ungroup() %>% 
  # selection vs. nonselection pivot wider
  pivot_wider(
    names_from = method, 
    values_from = c(contains("bggm")),
    names_sep = "_"
  ) %>% 
    rename_with(~ gsub("_bggm_", "_", .), contains("_bggm_"))

```

### Plotting results

Prepare plotting. 

```{r}
# Timepoint values with all levels
tp_levels <- c("50" = "1", "100" = "2", "200" = "3", "400" = "4", "1000" = "5")

# DGP cut: should old dgps be cut? then set this to 2
# if not, set to 0
dgp_cut <- 2

# DGP Names
dgp_levels <- c("Old1" = "1", "Old2" = "2", "Empirical\nSparse" = "3",
                 "Simulated\nChain 6N" = "4", "Simulated\nNonsparse" = "5",
                 "Simulated\nChain 8N" = "6")

# With deleting old DGPs
dgp_levels <- c("Empirical\nSparse" = "3",
                 "Simulated\nChain 6N" = "4", "Simulated\nNonsparse" = "5",
                 "Simulated\nChain 8N" = "6")

# Colors and linetypes consistent across plots
cond_colors <- set_names(ggokabeito::palette_okabe_ito()[1:5],
                         c("BGGM narrow", "BGGM wide", "graphicalVAR", "SEL wide", "SEL narrow"))

cond_lty <- set_names(c(1,1,1,2,2),
                      c("BGGM narrow", "BGGM wide", "graphicalVAR", "SEL wide", "SEL narrow"))

```


## Plots with uncertainty
Prepare data: Pivot longer and mutate columns. 
```{r}
# Pivot longer and mutate columns
df_eval_both_long <- df_eval_both %>% 
  ungroup() %>% 
  # Filter irrelevant condition
  dplyr::filter(!(!is.na(lambda) & ebic == 0.5)) %>% 
  tidyr::pivot_longer(cols = c(contains("bias"), 
                               contains("cor"), 
                               contains("mcse"), 
                               contains("spec"), 
                               contains("sens"))) %>%
  mutate(val_type = case_when(
    stringr::str_detect(name, "mcse") ~ "mcse",
    TRUE ~ "value"
  )) %>%   
  mutate(method = case_when(
    stringr::str_detect(name, "bggm") ~ "BGGM",
    stringr::str_detect(name, "sel") ~ "SEL",
    stringr::str_detect(name, "gvar") ~ "graphicalVAR"
  )) %>% 
  mutate(name = stringr::str_remove(name, "_.*")) %>% 
  rename(stat = name) %>% 
  pivot_wider(names_from = val_type, 
              values_from = value) %>% 
  mutate(mat = case_when(
    stringr::str_detect(mat, "beta") ~ "Temporal",
    stringr::str_detect(mat, "pcor") ~ "Contemporaneous"
  )) %>% 
 mutate(stat = case_when(
                          stringr::str_detect(stat, "sens") ~ "Sensitivity",
                          stringr::str_detect(stat, "spec") ~ "Specificity",
                          stringr::str_detect(stat, "bias") ~ "Bias",
                          stringr::str_detect(stat, "cor") ~ "Correlation"))
  
  

```




### Plot BGGM
This is not done yet; I need to think about what to include.
```{r}
ls_data_eval_bggm <- df_eval_both_long %>% 
  filter(dgp_ind > dgp_cut) %>% 
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  filter(method != "graphicalVAR") %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  # filter to one graphicalVAR method, such that BGGM is not repeated
  filter(is.na(lambda) & ebic == 0) %>% 
  # not look at spec/sens here
  filter(!stat %in% c("Sensitivity", "Specificity")) %>%
  # Look at specific prior combinations
  filter(prior_comb %in% c("b0.2_r0.1", "b0.2_r0.5",
                           "b0.5_r0.5", "b1_r0.1")) %>% 
  # Nice labels for plotting
  # mutate(prior_comb = factor(prior_comb,
  #                       levels = c("b0.2_r0.1", "b0.2_r0.5", "b0.5_r0.5", "b1_r0.1"),
  #                       labels = c(expression(s[beta]~"= 0.2, "~ s[rho]~"= 0.1"),
  #                                  expression(s[beta]~"= 0.2, "~ s[rho]~"= 0.5"),
  #                                  expression(s[beta]~"= 0.5, "~ s[rho]~"= 0.5"),
  #                                  expression(s[beta]~"= 1, "~ s[rho]~"= 0.1")
  #                                  ))) %>% 
  # Create combined method
  mutate(method = paste0(method, "_", prior_comb)) %>%
  # Split based on statistic to obtain different y-axes
  split(., .$stat)


# # # Create line types for different methods
# cond_lty_bggm <- set_names(c(1,1, 1, 1, 2, 2, 2, 2),
#                       c("BGGM_b0.2_r0.1", "BGGM_b0.2_r0.5", "BGGM_b0.5_r0.5", "BGGM_b1_r0.1",
#                         "SEL_b0.2_r0.1", "SEL_b0.2_r0.5", "SEL_b0.5_r0.5", "SEL_b1_r0.1"))
# cond_colors_bggm <- set_names(ggokabeito::palette_okabe_ito()[1:8],
#                          c("BGGM_b0.2_r0.1", "BGGM_b0.2_r0.5", "BGGM_b0.5_r0.5", "BGGM_b1_r0.1",
#                         "SEL_b0.2_r0.1", "SEL_b0.2_r0.5", "SEL_b0.5_r0.5", "SEL_b1_r0.1"))


ls_eval_bggm_both_plots <- list()    
ls_eval_bggm_both_plots[[1]] <- ggplot(data = ls_data_eval_bggm$Bias, 
         aes(x = tp_ind, y = value, col = method, group = method))+
  geom_linerange(aes(ymin = value - 1.96*mcse,
                            ymax = value + 1.96*mcse),
                        width = .5, 
                 # position = position_dodge(0.1)
                 show.legend = FALSE)+
  geom_line()+
  # geom_point()+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat),
                      axes = TRUE,
                      remove_labels = TRUE)+
  # scale_color_manual(values = ggokabeito::palette_okabe_ito()[1:8])+
  # scale_linetype_manual(values = c(1,1, 1, 1, 2, 2, 2, 2))+
  ggokabeito::scale_color_okabe_ito()+
  labs(x = "Timepoints",
       col = "Method",
       group = "Method",
       y = "")+
  theme_compare()+
  scale_y_continuous(limits = c(0,.2), breaks = c(0, .05, .1, .15, .2), expand = c(0,0))+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        strip.text.y = element_blank(),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        axis.line = element_line(colour = "#6d6d6e"),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

ls_eval_bggm_both_plots[[2]] <- ggplot(data = ls_data_eval_bggm$Correlation, 
         aes(x = tp_ind, y = value, col = method,  group = method))+

  geom_linerange(aes(ymin = value - 1.96*mcse,
                            ymax = value + 1.96*mcse),
                        width = .5, 
                 # position = position_dodge(0.1)
                 show.legend = FALSE)+
  geom_line()+
  # geom_point()+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat),
                      axes = TRUE,
                      remove_labels = TRUE)+
  # scale_color_manual(values = ggokabeito::palette_okabe_ito()[1:8])+
  # scale_linetype_manual(values = c(1,1, 1, 1, 2, 2, 2, 2))+
  ggokabeito::scale_color_okabe_ito()+
  labs(x = "Timepoints",
       col = "Method",
       group = "Method",
       y = "")+
  theme_compare()+
  scale_y_continuous(limits = c(0,1), breaks = c(0, .25, .5, .75, 1), expand = c(0,0))+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        axis.line = element_line(colour = "#6d6d6e"),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))


plot_eval_bggm_separate <- patchwork::wrap_plots(ls_eval_bggm_both_plots) + 
  patchwork::plot_layout(guides = "collect") & theme(legend.position = "top")
plot_eval_bggm_separate

ggsave("plot_eval_bggm.svg", plot_eval_bggm_separate, height = 9, width = 12, path = here::here("figures/"), device = "svg")
  
```

### Plot graphicalVAR
Extensive plot for supplement.
```{r}
plot_eval_graphicalvar <- df_eval_both_long %>% 
  filter(dgp_ind > dgp_cut) %>% 
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  filter(method == "graphicalVAR") %>% 
  dplyr::mutate(lambda = as.character(lambda)) %>% 
  dplyr::mutate(lambda = tidyr::replace_na(lambda, "default")) %>% 
  dplyr::mutate(ebic_lambda_comb = paste0("Gamma: ", ebic, ", Lambda = ", lambda)) %>% 
  # filter redundant condition
  # EBIC is irrelevant when not regularizing, so this is 
  # identical to using Gamma: 0
  dplyr::filter(ebic_lambda_comb != "Gamma: 0.5, Lambda = 0") %>% 
  # filter to one BGGM method, such that graphicalVAR is not repeated
  filter(rho_prior == 0.1 & beta_prior == 0.2) %>%
  # not look at spec/sens here
  filter(!stat %in% c("Sensitivity", "Specificity")) %>%
  ggplot(aes(x = tp_ind, y = value, col = ebic_lambda_comb, group = ebic_lambda_comb))+
  geom_line()+
  geom_linerange(aes(ymin = value - 1.96*mcse,
                            ymax = value + 1.96*mcse),
                        width = .5, 
                 # position = position_dodge(0.1)
                 show.legend = FALSE)+
  # geom_point()+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat),
                      axes = TRUE,
                      remove_labels = TRUE)+
  theme_bw()+
  # scale_color_manual(values = cond_colors)+
  # scale_linetype_manual(values = cond_lty)+
  ggokabeito::scale_color_okabe_ito()+
  labs(x = "Timepoints",
       col = "Method",
       y = "",
       linetype = "Method")+
  theme_compare()+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.line = element_line(colour = "#6d6d6e"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

plot_eval_graphicalvar

ggsave("plot_eval_graphicalvar.svg", plot_eval_graphicalvar, height = 9, width = 12, path = here::here("figures/"), device = "svg")
```


### Plot both

With separate y-axis scaling.
```{r}
ls_data_both_stat <- df_eval_both_long %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  dplyr::group_by(dgp_ind, tp_ind, lambda, ebic, prior_comb) %>% 
  mutate(method = paste0(method, "_", prior_comb)) %>% 
  mutate(method = case_when(
    stringr::str_detect(method, "BGGM_b0.2") ~ "BGGM narrow",
    stringr::str_detect(method, "BGGM_b1") ~ "BGGM wide",
    stringr::str_detect(method, "graphicalVAR") ~ "graphicalVAR",
    stringr::str_detect(method, "SEL_b0.2") ~ "SEL narrow",
    stringr::str_detect(method, "SEL_b1") ~ "SEL wide"
  )) %>% 
  # only take default values for now
  filter(is.na(lambda) & ebic == 0) %>% 
  # not look at spec/sens here
  filter(!stat %in% c("Sensitivity", "Specificity")) %>% 
  # Split based on statistic to obtain different y-axes
  split(., .$stat)

ls_eval_both_plots <- list()    
ls_eval_both_plots[[1]] <- ggplot(data = ls_data_both_stat$Bias, 
         aes(x = tp_ind, y = value, col = method, linetype = method, group = method))+
  geom_linerange(aes(ymin = value - 1.96*mcse,
                            ymax = value + 1.96*mcse),
                        width = .5, 
                 # position = position_dodge(0.1)
                 show.legend = FALSE)+
  geom_line()+
  # geom_point()+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat),
                      axes = TRUE,
                      remove_labels = TRUE)+
  scale_color_manual(values = cond_colors)+
  scale_linetype_manual(values = cond_lty)+
  labs(x = "Timepoints",
       col = "Method",
       group = "Method",
       y = "",
       linetype = "Method")+
  theme_compare()+
  scale_y_continuous(limits = c(0,.2), breaks = c(0, .05, .1, .15, .2), expand = c(0,0))+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        strip.text.y = element_blank(),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        axis.line = element_line(colour = "#6d6d6e"),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

ls_eval_both_plots[[2]] <- ggplot(data = ls_data_both_stat$Correlation, 
         aes(x = tp_ind, y = value, col = method, linetype = method, group = method))+

  geom_linerange(aes(ymin = value - 1.96*mcse,
                            ymax = value + 1.96*mcse),
                        width = .5, 
                 # position = position_dodge(0.1)
                 show.legend = FALSE)+
  geom_line()+
  # geom_point()+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat),
                      axes = TRUE,
                      remove_labels = TRUE)+
  scale_color_manual(values = cond_colors)+
  scale_linetype_manual(values = cond_lty)+
  labs(x = "Timepoints",
       col = "Method",
       group = "Method",
       y = "",
       linetype = "Method")+
  theme_compare()+
  scale_y_continuous(limits = c(0,1), breaks = c(0, .25, .5, .75, 1), expand = c(0,0))+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        axis.line = element_line(colour = "#6d6d6e"),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

  


plot_eval_both_separate <- patchwork::wrap_plots(ls_eval_both_plots) + 
  patchwork::plot_layout(guides = "collect") & theme(legend.position = "top")

plot_eval_both_separate
ggsave("plot_eval_both_cor_separate.svg", plot_eval_both_separate, height = 9, width = 12, path = here::here("figures/"), device = "svg")



```




### Plot Selection Methods
```{r}
plot_eval_select <- df_eval_both_long %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  dplyr::group_by(dgp_ind, tp_ind, lambda, ebic, prior_comb) %>% 
  mutate(method = paste0(method, "_", prior_comb)) %>% 
  mutate(method = case_when(
    stringr::str_detect(method, "BGGM_b0.2") ~ "BGGM narrow",
    stringr::str_detect(method, "BGGM_b1") ~ "BGGM wide",
    stringr::str_detect(method, "graphicalVAR") ~ "graphicalVAR",
    stringr::str_detect(method, "SEL_b0.2") ~ "SEL narrow",
    stringr::str_detect(method, "SEL_b1") ~ "SEL wide"
  )) %>% 
  # disregard non-select methods
  filter(!grepl("BGGM", method)) %>% 
  # only take default values for now
  filter(is.na(lambda) & ebic == 0) %>% 
  # not look at spec/sens here
  filter(stat %in% c("Sensitivity", "Specificity")) %>% 
  ggplot(aes(x = tp_ind, y = value, col = method,linetype = method, group = method))+
  geom_line()+
  geom_linerange(aes(ymin = value - 1.96*mcse,
                            ymax = value + 1.96*mcse),
                        width = .5, 
                 # position = position_dodge(0.1)
                 show.legend = FALSE)+
  # geom_point()+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat),
                      axes = TRUE,
                      remove_labels = TRUE)+
  scale_y_continuous(expand = c(0,0), 
                     limits = c(0,1), 
                     breaks = c(0,0.25, 0.5, 0.75, 1))+
  scale_color_manual(values = cond_colors)+
  scale_linetype_manual(values = cond_lty)+
  labs(x = "Timepoints",
       col = "Method",
       y = "",
       linetype = "Select")+
  theme_compare()+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        axis.line = element_line(colour = "#6d6d6e"),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

plot_eval_select
ggsave("plot_eval_select.svg", plot_eval_select, height = 9, width = 12, path = here::here("figures/"), device = "svg")


```


### Plot selection CI sensitivity
First, calculate SE for all credible intervals. 
```{r}
n_rep = 1000

plot_ci_sens <- df_eval_bggm %>% 
  dplyr::select(dgp_ind, tp_ind, rho_prior, beta_prior, contains("ci_sens"), contains("ci_spec")) %>% 
  rename_with(~ gsub("ci_", "", .), contains("ci_")) %>% 
  pivot_longer(cols = c(contains("_beta"), contains("_pcor"))) %>% 
  mutate(stat = case_when(
                           stringr::str_detect(name, "sens") ~ "Sensitivity", 
                           stringr::str_detect(name, "spec") ~ "Specificity")) %>% 
  mutate(mat = case_when(
                           stringr::str_detect(name, "beta") ~ "Temporal", 
                           stringr::str_detect(name, "pcor") ~ "Contemporaneous")) %>% 
  mutate(ci = case_when(
                           stringr::str_detect(name, "0.9$") ~ "0.90", 
                           stringr::str_detect(name, "0.95") ~ "0.95",
                          stringr::str_detect(name, "0.99") ~ "0.99")) %>% 
  dplyr::select(!name) %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  # only one prior for now
  filter(prior_comb == "b0.2_r0.3") %>% 
  mutate(ci = as.factor(ci)) %>% 
  dplyr::select(!contains("prior")) %>%
  group_by(dgp_ind, tp_ind, stat, mat, ci) %>% 
  # Calculate mcse
  summarize(
    mean_stat = mean(value), 
    mean_mcse = sqrt((mean_stat * (1-mean_stat))/n_rep)) %>% 
  ungroup() %>% 
  ggplot(aes(x = tp_ind, y = mean_stat, col = ci, group = ci))+
  geom_line()+
  geom_linerange(aes(ymin = mean_stat - 1.96*mean_mcse,
                            ymax = mean_stat + 1.96*mean_mcse),
                        width = .5,
                 # position = position_dodge(0.1)
                 show.legend = FALSE)+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat),
                      axes = TRUE,
                      remove_labels = TRUE)+
  # scale_color_manual(values = cond_colors)+
  labs(x = "Timepoints",
       col = "CI Width",
       y = "")+
  theme_compare()+
  ggokabeito::scale_color_okabe_ito()+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.line = element_line(colour = "#6d6d6e"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

plot_ci_sens

ggsave("plot_ci_sens.svg", plot_ci_sens, height = 9, width = 12, path = here::here("figures/"), device = "svg")

  
```



### Focus on nonselect methods

With standard errors.
```{r}
ls_data_both_nonselect <- df_eval_both_long %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  filter(method != "SEL") %>% 
  dplyr::group_by(dgp_ind, tp_ind, lambda, ebic, prior_comb) %>% 
  mutate(method = paste0(method, "_", prior_comb)) %>% 
  mutate(method = case_when(
    stringr::str_detect(method, "BGGM_b0.2") ~ "BGGM narrow",
    stringr::str_detect(method, "BGGM_b1") ~ "BGGM wide",
    stringr::str_detect(method, "graphicalVAR") ~ "graphicalVAR"
  )) %>% 
  # find nonreguldarized graphicalVAR
  filter(lambda == 0 & ebic == 0) %>% 
  # not look at spec/sens here
  filter(!stat %in% c("Sensitivity", "Specificity")) %>% 
  # Split based on statistic to obtain different y-axes
  split(., .$stat)

ls_eval_both_nonselect <- list()    
ls_eval_both_nonselect[[1]] <- ggplot(data = ls_data_both_nonselect$Bias, 
         aes(x = tp_ind, y = value, col = method, linetype = method, group = method))+
  geom_linerange(aes(ymin = value - 1.96*mcse,
                            ymax = value + 1.96*mcse),
                        width = .5, 
                 # position = position_dodge(0.1)
                 show.legend = FALSE)+
  geom_line()+
  # geom_point()+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat))+
  theme_bw()+
  scale_color_manual(values = cond_colors)+
  scale_linetype_manual(values = cond_lty)+
  labs(x = "Timepoints",
       col = "Method",
       group = "Method",
       y = "",
       linetype = "Method")+
  theme_compare()+
  scale_y_continuous(limits = c(0,.2), breaks = c(0, .05, .1, .15, .2))+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        strip.text.y = element_blank(),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

ls_eval_both_nonselect[[2]] <- ggplot(data = ls_data_both_nonselect$Correlation, 
         aes(x = tp_ind, y = value, col = method, linetype = method, group = method))+

  geom_linerange(aes(ymin = value - 1.96*mcse,
                            ymax = value + 1.96*mcse),
                        width = .5, 
                 # position = position_dodge(0.1)
                 show.legend = FALSE)+
  geom_line()+
  # geom_point()+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat))+
  theme_bw()+
  scale_color_manual(values = cond_colors)+
  scale_linetype_manual(values = cond_lty)+
  labs(x = "Timepoints",
       col = "Method",
       group = "Method",
       y = "",
       linetype = "Method")+
  theme_compare()+
  scale_y_continuous(limits = c(0,1), breaks = c(0, .25, .5, .75, 1))+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

  


plot_eval_both_nonselect <- patchwork::wrap_plots(ls_eval_both_nonselect) + 
  patchwork::plot_layout(guides = "collect") & theme(legend.position = "top")

plot_eval_both_nonselect
ggsave("plot_eval_both_cor_nonselect.svg", plot_eval_both_nonselect, height = 9, width = 12, path = here::here("figures/"), device = "svg")



```




### Coverage and interval width BGGM

Create a plot to investigate credible intervals of BGGM with uncertainty. 
```{r}
plot_eval_credible <- df_eval_both %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # only take default values for gvar now to filter out redundant information
  filter(is.na(lambda) & ebic == 0) %>% 
  dplyr::select(-c(lambda,ebic)) %>% 
  dplyr::select(c(dgp_ind, tp_ind, contains("prior"), contains("width"),contains("cover"))) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  dplyr::group_by(dgp_ind, tp_ind, prior_comb) %>% 
  # convert coverage into proportion
  mutate(n_nodes = ifelse(dgp_ind == "Simulated\nChain 8N", 8, 6)) %>% 
  mutate(across(contains("sum_cover_beta"),
                ~ ./n_nodes^2)) %>% 
  # divide by number of unique off-diagonal elements
  mutate(across(contains("sum_cover_pcor"),
                ~ ./((n_nodes/2)*(n_nodes-1)))) %>% 
  # dplyr::summarize(across(c(contains("width"), contains("cover")),
  #                  ~mean(., na.rm = TRUE))) %>% 
  pivot_longer(cols = c(contains("width"), contains("cover")),
                        names_to = "stat") %>%
  mutate(mat = case_when(
    stringr::str_detect(stat, "beta") ~ "Temp.",
    stringr::str_detect(stat, "pcor") ~ "Contemp."
  )) %>% 
  # add line for coverage
  mutate(intercept = case_when(
    stringr::str_detect(stat, "cover_beta_0.9$") ~ 0.9,
    stringr::str_detect(stat, "cover_beta_0.95") ~ 0.95,
    stringr::str_detect(stat, "cover_beta_0.99") ~ 0.99,
    stringr::str_detect(stat, "cover_pcor_0.9$") ~ 0.9,
    stringr::str_detect(stat, "cover_pcor_0.95") ~ 0.95,
    stringr::str_detect(stat, "cover_pcor_0.99") ~ 0.99,
    .default = 0
  )) %>% 
  # Little trick to not show horizontal line for the width facets
  mutate(line_alpha = case_when(
    stringr::str_detect(stat, "cover") ~ 1,
    stringr::str_detect(stat, "width") ~ 0
  )) %>% 
    mutate(stat = case_when(
    stringr::str_detect(stat, "width_beta_0.9$") ~ "Width 0.9",
    stringr::str_detect(stat, "width_beta_0.95") ~ "Width 0.95",
    stringr::str_detect(stat, "width_beta_0.99") ~ "Width 0.99",
    stringr::str_detect(stat, "width_pcor_0.9$") ~ "Width 0.9",
    stringr::str_detect(stat, "width_pcor_0.95") ~ "Width 0.95",
    stringr::str_detect(stat, "width_pcor_0.99") ~ "Width 0.99",
    stringr::str_detect(stat, "cover_beta_0.9$") ~ "Coverage 0.9",
    stringr::str_detect(stat, "cover_beta_0.95") ~ "Coverage 0.95",
    stringr::str_detect(stat, "cover_beta_0.99") ~ "Coverage 0.99",
    stringr::str_detect(stat, "cover_pcor_0.9$") ~ "Coverage 0.9",
    stringr::str_detect(stat, "cover_pcor_0.95") ~ "Coverage 0.95",
    stringr::str_detect(stat, "cover_pcor_0.99") ~ "Coverage 0.99",
  )) %>% 
  
  # Proper names for prior
    mutate(prior_comb = case_when(
    stringr::str_detect(prior_comb , "b0.2") ~ "BGGM narrow",
    stringr::str_detect(prior_comb , "b1") ~ "BGGM wide"
  )) %>% 
  dplyr::filter(!grepl("Width", stat)) %>% 
  ggplot(aes(x = tp_ind, y = value, col = prior_comb, group = prior_comb))+
  geom_hline(aes(yintercept = intercept, alpha = line_alpha), 
             col = "#D5D8DC", show.legend = FALSE)+
  geom_boxplot(outlier.size = 0.5, outlier.alpha = 0.4, outlier.color = "grey")+
  scale_y_continuous(limits = c(.5,1), breaks = c(.5, .6, .7, .8, .9, 1))+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat))+
  scale_color_manual(values = cond_colors)+
  labs(x = "Timepoints",
       col = "Priors",
       y = "")+
  theme_compare()

plot_eval_credible 
ggsave("plot_eval_credible.svg", plot_eval_credible, height = 7, width = 12, path = here::here("figures/"), device = "svg")

```



Obtain numerical results:
```{r}
df_eval_both %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # only take default values for gvar now to filter out redundant information
  filter(is.na(lambda) & ebic == 0) %>% 
  dplyr::select(-c(lambda,ebic)) %>% 
  dplyr::select(c(dgp_ind, tp_ind, contains("prior"), contains("width"),contains("cover"))) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  dplyr::group_by(dgp_ind, tp_ind, prior_comb) %>% 
  # convert coverage into proportion
  mutate(n_nodes = ifelse(dgp_ind == "Simulated\nChain 8N", 8, 6)) %>% 
  mutate(across(contains("sum_cover_beta"),
                ~ ./n_nodes^2)) %>% 
  # divide by number of unique off-diagonal elements
  mutate(across(contains("sum_cover_pcor"),
                ~ ./((n_nodes/2)*(n_nodes-1)))) %>% 
  dplyr::summarize(across(c(contains("width"), contains("cover")),
                   ~mean(., na.rm = TRUE))) %>% 
  pivot_longer(cols = c(contains("width"), contains("cover")),
                        names_to = "stat") %>%
  mutate(mat = case_when(
    stringr::str_detect(stat, "beta") ~ "Temp.",
    stringr::str_detect(stat, "pcor") ~ "Contemp."
  )) %>% 
  filter(grepl("sum_cover", stat)) %>% 
  # extract nominal CI value
  mutate(ci_nominal = as.numeric(str_extract(stat, "\\d+\\.\\d+$"))) %>% 
  mutate(ci_nominal_diff = value - ci_nominal) %>% 
  # group_by(prior_comb, tp_ind, stat, dgp_ind) %>% 
  # dplyr::summarize(mean_diff = mean(ci_nominal_diff)) %>% 
  ungroup() %>% 
  dplyr::summarize(median_diff = stats::median(abs(ci_nominal_diff)))
  

```



