---
title: "var-resample"
author: "Bj√∂rn Siepe"
date: "`r Sys.Date()"
output: html_document
---

# Background


```{r preparations, include = FALSE}
library(tidyverse)
library(graphicalVAR)
library(doParallel)
library(doRNG)         # reproducibility for parallelization
library(mgm)
library(mlVAR)
library(BGGM)
# library("BGGM", lib.loc = "C:/Users/Bjoern/R-dev")
library(reshape2)      # Data manipulation
library(mvtnorm)       # Sim from posterior
library(stats)         # KS-Test
# library(philentropy)   # divergence measures
# library(todor)         # keep on track with stuff to do
source("aux_funs.R")
# library(ggokabeito)
library(Matrix)
library(here)
library(rrapply)       # deeply nested list
library(ggh4x)
here::i_am("var-compare.Rproj")


seed = 2022
set.seed(seed)
```



Dataset overview:
- l_raw: Contains `n_mod` datasets sampled from specific DGP.
- l_res: Contains `n_ind`fitted models, one for each l_raw. Represents different people under same DGP.  
- l_params: Contains posterior beta and kappa matrices for each fitted model in l_res.
- 

New data-generating processes by Hoekstra:
She used PDC and PCC instead of beta and kappa. Maybe I won't use her dgps after all. 
For now, pretend that she used beta and kappa, so we likely use a bit sparser graphs than she did.
```{r dgp-hoekstra}
```


```{r dgp-fried}
fried_net <- readRDS(here("data/graph_fried.Rds"))

graph_fried <- list()
graph_fried$beta <- fried_net$beta
graph_fried$kappa <- fried_net$kappa

# For now, delete 3 edges so that every dgp has 6 vars
graph_fried$beta <- graph_fried$beta[1:6, 1:6]
graph_fried$kappa <- graph_fried$kappa[1:6, 1:6]
```


```{r own-graph}
graph <- readRDS(here::here("data/graph.RDS"))
# delete PCC (not needed)
graph <- graph[-3]


```

Graph with non-sparsity
```{r}
graph_full_f <- readRDS("full_graph.RDS")

graph_full <- list(
  beta = graph_full_f$beta_mu,
  kappa = graph_full_f$kappa_mu
)
# Non-symmetric Kappa due to rounding errors
graph_full$kappa <- as.matrix(Matrix::forceSymmetric(graph_full$kappa))

```

Chain Graph Hoekstra
```{r}
graph_hoekstra_6node <- readRDS(here::here("data/hoekstra_synth_6node.RDS"))


```

Synthetic non-sparse graph
```{r}
graph5 <- readRDS(here::here("data/graph5.RDS"))

```

## Simulation Conditions
```{r}
# Simulation conditions
n_ind <- 100 # number of individuals(so models to create) 
n_tp <- c(50,100,200,400, 1000) # number of timepoints
n_postds <- 120 # number of posterior datasets
seed <- 2022
dgp_names <- c("graph1", "graph2", "graph3", "graph4", "graph5")
```





## Change Graphs
Now we can change all graphs according to the simulation conditions.
```{r change-graphs}
# Store graphs as list
# l_graphs <- list(graph1 = graph,
#                  graph2 = graph_full, 
#                  graph3 = graph_fried,
#                  graph4 = graph_hoekstra_6node,
#                  graph5 = graph5)

l_graphs <- readRDS("data/l_graphs.RDS")
l_graphs <- l_graphs[-6]
l_changed_graphs <-readRDS("data/l_changed_graphs_0305.RDS")

# Apply change function to every graph
l_changed_graphs <- lapply(l_graphs,
                           function(x) {change_graphs(
                                            truegraph = x,
                                            changemax = c(1.4, 1.6),
                                            noise = c(0.1,0.2,0.3),
                                            const = c(0.05, 0.1, 0.15),
                                            permute_active = FALSE,
                                            seed = seed)})

# # again for graph5 
# l_change5 <- change_graphs(truegraph = l_graphs$graph5,
#                            changemax = c(1.2, 1.4, 1.6),
#                                             noise = c(0.1,0.2,0.3),
#                                             permute_active = FALSE,
#                                             seed = 2023)
# 
# l_changed_graphs$graph5$noise0.2 <- l_change5$noise0.2


# write_rds(l_changed_graphs, "data/l_changed_graphs.RDS")
# write_rds(l_graphs, "data/l_graphs.RDS")

```

Get change matrices for supplement
```{r}
l_diff_mat <- list()

# loop over dgps 
for(i in 1:5){
  l_diff_mat[[i]] <- list()
  # loop over noise structures
  ct <- 0
  for(ch in 7:9){
    ct <- ct+1
    l_diff_mat[[i]][[ct]] <- list()
    l_diff_mat[[i]][[ct]]$beta <- round(l_changed_graphs[[i]][[ch]]$beta-l_changed_graphs[[i]]$truegraph$beta,3)
    l_diff_mat[[i]][[ct]]$pcor <- round((-1*stats::cov2cor(l_changed_graphs[[i]][[ch]]$kappa))-(-1*stats::cov2cor(l_changed_graphs[[i]]$truegraph$kappa)),3)
  }
    
  
}

# function from https://www.r-bloggers.com/2020/08/matrix-to-latex/
array_to_latex <- function(arr){
rows <- apply(arr, MARGIN=1, paste, collapse = " & ")
matrix_string <- paste(rows, collapse = " \\\\ ")
return(paste("\\begin{bsmallmatrix}", matrix_string, "\\end{bsmallmatrix}"))
}

# For beta, identical across dgps
array_to_latex(l_diff_mat[[5]][[1]]$beta)
array_to_latex(l_diff_mat[[5]][[2]]$beta)
array_to_latex(l_diff_mat[[5]][[3]]$beta)

lapply(l_diff_mat, function(x){
  lapply(x, function(y) mean(abs(y$beta)))
})


lapply(l_diff_mat, function(x){
  lapply(x, function(y) mean(abs(y$pcor[y$pcor != 0])))
})

# For kappa, slightly different
array_to_latex(l_diff_mat[[3]][[1]]$pcor)
array_to_latex(l_diff_mat[[3]][[2]]$pcor)
array_to_latex(l_diff_mat[[5]][[3]]$pcor)

```



## Simulate Raw Data
Then, generate rawdata from data-generating processes. We create more posterior datasets than we fit in the end, because some of them may not converge when using the posterior predictive approach. 

```{r generate-rawdata-parallel}
# Changed: instead of n_ind, we create n_postds datasets 
# because some models don't converge
before_simraw <- Sys.time()
ncores = 40
cl = makeCluster(ncores)
registerDoParallel(cl)
l_raw_new <- list()

for(dgp in dgp_names){
  l_raw_new[[dgp]] <- list()
  for(t in seq_along(n_tp)){
      l_raw_new[[dgp]][[t]] <- lapply(l_changed_graphs[[dgp]],
                                        function(x) sim_raw_parallel(dgp = x, 
                                                                     n = n_postds, 
                                                                     tp = n_tp[t], 
                                                                     seed = seed, 
                                                                     means = 0, 
                                                                     standardize = TRUE))
    
  }
}

stopCluster(cl)

after_simraw <- Sys.time()-before_simraw  # less than 4 minutes

# write_rds(l_raw, "data/l_raw_new_1703.RDS")
l_raw <- readRDS(here::here("data/l_raw_new_1703.RDS"))

for(dgp in dgp_names){
  for(t in seq_along(n_tp)){
    l_raw[[dgp]][[t]]$noise0.2 <- l_raw_new[[dgp]][[t]]$noise0.2
    l_raw[[dgp]][[t]]$const0.05 <- l_raw_new[[dgp]][[t]]$const0.05
    l_raw[[dgp]][[t]]$const0.1 <- l_raw_new[[dgp]][[t]]$const0.1
    l_raw[[dgp]][[t]]$const0.15 <- l_raw_new[[dgp]][[t]]$const0.15
  }
}

```


### Raw data permutation
As a new change condition, just change variable indexes in the data before fitting. 
```{r}
for(dgp in dgp_names){
  for(t in seq_along(n_tp)){
    l_raw[[dgp]][[t]]$permute <- lapply(l_raw[[dgp]][[t]]$truegraph,
                                  function(x) {
                                    x$data <- x$data[,c(1,3,4,2,5,6)]
                                    x$args$dgp <- "permute134256" 
                                    x
                                  })
    
  }
}
```






# Bayesian approach
Fit a VAR model to each raw dataset. 
```{r}
# model parameters
rho_sd <- 0.5      # Prior for partial correlations
beta_sd <- 1       # Prior for regression matrix
seed <- 2022
n_iter <- 50000


# Prior switch
prior_wide <- FALSE
ifelse(prior_wide, 
       {
         rho_sd <- 0.5
         beta_sd <- 1
       },
       {
         rho_sd <- 0.25
         beta_sd <- 0.2
       })



before_fitraw <- Sys.time()
ncores = 50
cl = makeCluster(ncores)
registerDoParallel(cl)
clusterExport(cl, c("fit_var_parallel_merged", "summarize_post"))

# Only compute for specific modification 
l_raw <- lapply(l_raw, function(x) lapply(x, function(y) list(
                                                              const0.05 = y$const0.05,
                                                              const0.1 = y$const0.1,
                                                              const0.15 = y$const0.15,
                                                              noise0.2 = y$noise0.2
                                                              )))

# dgp_names <- c("graph1", "graph2", "graph3", "graph4", "graph5")
dgp_names <- c("graph3", "graph4", "graph5")
for(dgp in dgp_names){
  for(t in seq_along(n_tp)){
    
    # output label based on prior
    dgp_string <- ifelse(prior_wide, dgp, paste0("narrow_",dgp))
    
    lapply(l_raw[[dgp]][[t]], 
           function(x){fit_var_parallel_merged(
                              data = x, 
                              n = n_ind, 
                              nds = n_postds, 
                              rho_prior = rho_sd, 
                              beta_prior = beta_sd, 
                              seed = seed, 
                              iterations = n_iter, 
                              get_kappa = FALSE, 
                              summarize_post = FALSE, 
                              pruneresults = FALSE, 
                              dgp_name = dgp_string, 
                              save_files = TRUE
  )})
  }
}
stopCluster(cl)
after_fitraw <- Sys.time()-before_fitraw


```



For the server: move some files to HDD
```{r}
l_copy <- list.files(path = here::here("data/compare_sim_fits"), pattern = "change")
file.copy(from = paste0(here::here("data/compare_sim_fits/"), l_copy),
          to = paste0("/home/bjoern/HDD/var-compare/data/", l_copy))


file.remove(from = paste0(here::here("data/compare_sim_fits/"), l_copy))

```


The other way around:
```{r}
l_copy <- list.files(path = here::here("/home/bjoern/HDD/var-compare/data/"), pattern = "truegraph")
l_copy <- l_copy[!grepl("graph1", l_copy)]
file.copy(from = paste0(here::here("/home/bjoern/HDD/var-compare/data/"), l_copy),
          to = paste0("data/compare_sim_fits/", l_copy))


```




# New Approach (25.01.2023): Posterior Comparison without Predictive

Compare all models:
```{r}
# Setup list of conditions
# All possible model combinations
comp_combinations <- expand_grid_unique(mod_a = seq(1, n_ind, 1),
                                 mod_b = seq(1, n_ind, 1))
# number of data-generating processes
n_dgp <- 5
# Number of comparison types
n_c_types <- 3

# Number of different graph structures
n_g_types <- 9

# Number of different tp conditions
n_t_types <- 5

dgp_names <- c("graph1", "graph2", "graph3", "graph4", "graph5")
dgp_names <- c("narrow_graph3", "narrow_graph4", "narrow_graph5")
dgp_names <- c("graph3", "graph4", "graph5")

change_names <- c("noise0.2", "const0.05", "const0.1", "const0.15")
change_names <- c("truegraph", "change1.4", "change1.6",
                  "noise0.1", "noise0.2", "noise0.3", 
                  "const0.05", "const0.1", "const0.15",
                  "permute134256")

comp_names <- c("frob","maxdiff", "l1")

comp_grid_mod <- expand.grid(mod_a = seq(1, n_ind, 1),
            mod_b = seq(1, n_ind, 1),
            dgp = dgp_names, 
            change = change_names,
            tp = n_tp,
            comp = comp_names)

# Filter redundant comparisons within truegraph
comp_grid_mod <- comp_grid_mod %>% 
  filter(!c(mod_a == mod_b & change == "truegraph")) 


# Number of comparison combinations
n_c_comb <- nrow(comp_grid_mod)

```


## Compare models 
Previous model objects became too large, now we read them in instead of keeping them in memory.
```{r}
comp_grid <- expand.grid(dgp = dgp_names, 
                         change = change_names, 
                         comp = comp_names,
                         tp = n_tp)
  
# Add filenames
comp_grid <- comp_grid %>% 
  mutate(ref_file = paste0("fit_", dgp, "_","truegraph","_",tp,".RDS"),
         comp_file = paste0("fit_", dgp, "_",change,"_",tp,".RDS"))


# Add filenames
comp_grid <- comp_grid %>% 
  mutate(ref_file = paste0("fit_", dgp, "_","truegraph","_",tp,".RDS"),
         comp_file = paste0("fit_", dgp, "_",change,"_",tp,".RDS"))


############################# NOT MORE THAN 3!!!!!!!!!!!!
before_comp <- Sys.time()
ncores <- 3
cl <- makeCluster(ncores)
clusterExport(cl, c("comp_grid",  "comp_grid_mod", "within_compare", "within_compare_eval", "post_distance_within", "here", "todo_files_num"))
clusterEvalQ(cl, library(tidyverse))

# todo change back to 1:nrow(comp_grid)
parLapply(cl = cl, todo_files_num, function(n){
  ## Get filter args
  dgp_it <- as.character(comp_grid$dgp[n])
  change_it <- as.character(comp_grid$change[n])
  tp_it <- as.numeric(as.character(comp_grid$tp[n]))
  comp_it <- as.character(comp_grid$comp[n])
  
  
  
  ## Read files
    l_ref <- readRDS(file = here::here(paste0("data/compare_sim_fits/", comp_grid$ref_file[n])))
    l_comp <- readRDS(file = here::here(paste0("data/compare_sim_fits/", comp_grid$comp_file[n])))
    
    


  ## Perform comparison 
  # Loop over all possible model combinations
  comp_ind <- comp_grid_mod %>% 
    mutate(dgp = as.character(dgp),
           change = as.character(change),
           tp = as.numeric(as.character(tp)),
           comp = as.character(comp)) %>% 
    filter(dgp == dgp_it &
           change == change_it &
           tp == tp_it &
           comp == comp_it)
  

  wc_res <- list()
  wc_res  <- lapply(c(1:nrow(comp_ind)), function(x){
    
    ## Get fitting args
    ma <- as.numeric(as.character(comp_ind$mod_a[x]))
    mb <- as.numeric(as.character(comp_ind$mod_b[x]))
    cmp <- as.character(comp_ind$comp[x])
    
    wc_res[[x]] <- list()
    wc_res[[x]] <- tryCatch({within_compare(mod_a = ma,
                      mod_b = mb,
                      fitpost_a = l_ref,
                      fitpost_b = l_comp,
                      fitemp_a = l_ref,
                      fitemp_b = l_comp,
                      n_datasets = 100,
                      n_draws = 1000,
                      comparison = cmp,
                      postpred = FALSE)}, error = function(e) NA)
  })
  
  # Save output
  saveRDS(wc_res, file = here::here(paste0("data/compare_sim_res/comp_",dgp_it, "_",change_it,"_", tp_it, "_",comp_it, ".RDS")))
  # print(paste0("Just finished row", n))
  
})

stopCluster(cl)
after_comp <- Sys.time()-before_comp



# Afterwards check if all combinations that should be there are indeed there! i.e. if all relevant files are present
exist_files <- list.files(path = here::here("data/compare_sim_res"))

desired_files <- vector(length = nrow(comp_grid))
desired_files <- data.frame(filename = rep(NA, nrow(comp_grid)),
                            rownum = seq(1,nrow(comp_grid), by = 1))
# desired_files <- list()
for(n in 1:nrow(comp_grid)){

  dgp_it <- as.character(comp_grid$dgp[n])
  change_it <- as.character(comp_grid$change[n])
  tp_it <- as.numeric(as.character(comp_grid$tp[n]))
  comp_it <- as.character(comp_grid$comp[n])
  
  desired_files[n,1]<- paste0("comp_", dgp_it, "_",change_it,"_", tp_it, "_",comp_it, ".RDS")
}
# Find files that were not created yet
todo_files <- setdiff(desired_files$filename, exist_files)
todo_files_num <- desired_files %>% 
  filter(!filename %in% exist_files) %>% 
  pull(rownum)
todo_files_num
# This then has to be passed back to the loop above

# Delete graph4 change1.2 for now
todo_files <- todo_files[-grep("graph1", todo_files)]

todo_files_num <- desired_files %>% 
  filter(!filename %in% exist_files) %>% 
  filter(!grepl("graph5_noise0.2", filename)) %>% 
  pull(rownum)

todo_files <- todo_files[grep("graph5", todo_files)]
todo_files_num <- desired_files %>% 
  filter(!filename %in% exist_files) %>% 
  filter(grepl("graph5", filename)) %>% 
  pull(rownum)

# Redo graph5_noise0.2
todo_files_num <- desired_files %>% 
  filter(str_detect(filename, "graph5_noise0.2")) %>% 
  pull(rownum)



```


For server: Moving files to HDD
```{r}
l_copy <- list.files(path = here::here("data/compare_sim_res"), pattern = "comp_graph5")
file.copy(from = paste0(here::here("data/compare_sim_res/"), l_copy),
          to = paste0("/home/bjoern/HDD/var-compare/data/compare_sim_res/", l_copy))

# NOTE - some files are accidentally called "compare_sim_rescomp..."


file.remove(from = paste0(here::here("data/compare_sim_res/"), l_copy))

```





Reading the files in again and extracting summary information for each
```{r}
file_list <- list.files(path = here::here("data/compare_sim_res"))


time_before_within_eval <- Sys.time()
# DONT GO TOO HIGH HERE!!!! FILES BECOME TOO LARGE
ncores = 3
cl = makeCluster(ncores)
registerDoParallel(cl)
l_comp_res <- list()
l_comp_res <- foreach(i = 1:length(file_list)) %dopar% {
  comp_res <- readRDS(here::here(paste0("data/compare_sim_res/",file_list[i])))
  
  ## Obtain information from filename
  file_str <- file_list[i]
  file_str_split <- strsplit(file_str, split = "_")
  # for non-narrow condition
  if(length(file_str_split[[1]]) == 5){
  dgp_it <- file_str_split[[1]][2]
  change_it <- file_str_split[[1]][3]
  tp_it <- file_str_split[[1]][4]
  comp_it <- file_str_split[[1]][5]
  # delete file ending 
  comp_it <- gsub("\\..*", "", comp_it)
  }
  # for narrow condition
  if(length(file_str_split[[1]]) == 6){
  dgp_it <- paste(file_str_split[[1]][2], file_str_split[[1]][3], sep = "_")
  change_it <- file_str_split[[1]][4]
  tp_it <- file_str_split[[1]][5]
  comp_it <- file_str_split[[1]][6]
  # delete file ending 
  comp_it <- gsub("\\..*", "", comp_it)
  }


  
  
  ## Evaluation
  # Loop over all comparisons
  eval_res <- list()
  eval_res <- lapply(comp_res, function(x){
    
    res <- tryCatch({within_compare_eval(x, kappa = FALSE)}, error = function(e) NA)
    res$dgp <- dgp_it
    res$change <- change_it
    res$tp <- tp_it
    res$comp <- comp_it
    if(is.list(x)){
      res$emp <-  x$emp[1]
    } else{
      res$emp <- NA
    }
    return(res)
  })
  
  
  
  ## Output
  # Combine all results into dataframe
  df_eval_res <- do.call(rbind.data.frame, eval_res)
  print(paste0("File ", i, " done!"))
  
  # Save output
  saveRDS(df_eval_res, file = here::here(paste0("data/compare_sim_eval/eval_res_",dgp_it, "_",change_it,"_", tp_it, "_",comp_it, ".RDS")))
  
}
stopCluster(cl)

time_after_within_eval <- Sys.time() - time_before_within_eval  

# df_comp_res <- do.call(rbind, l_comp_res)
# write_rds(df_comp_res, "df_comp_res.RDS")


# Check which files are missing
exist_files_res <- list.files(path = here::here("data/compare_sim_res"))
exist_files_eval <- list.files(path = here::here("data/compare_sim_eval"))
desired_files <- gsub("comp", "eval_res",exist_files_res)

desired_files <- setdiff(desired_files, exist_files_eval)
file_list <- gsub("eval_res", "comp",desired_files)

# This then has to be passed back to the loop above
# to_del <- list.files(path = here::here("data/compare_sim_eval/"), pattern = "narrow")
# file.remove(from = paste0(here::here("data/compare_sim_eval/"), to_del))



```


Read in results again, they were saved as individual files. 
```{r}
# For wide priors
file_list <- list.files(path = "data/compare_sim_eval", full.names = TRUE)
file_list_w <- file_list[-grep("_narrow_", file_list)]
l_comp_res <- lapply(file_list_w, readRDS)
df_comp_res <- do.call(rbind, l_comp_res)

# Filter out redundant comparisons
df_comp_res <- df_comp_res %>% 
  filter(mod_a < mod_b)

# write_rds(df_comp_res, here::here("data/df_comp_res_wide_1905.RDS"))
df_comp_res <- readRDS(here::here("data/df_comp_res_wide_1905.RDS"))



# For narrow priors
file_list <- list.files(path = "data/compare_sim_eval", full.names = TRUE)
file_list_n <- file_list[grep("_narrow_", file_list)]
l_comp_res_n <- lapply(file_list_n, readRDS)
df_comp_res_n <- do.call(rbind, l_comp_res_n)

# Filter out redundant comparisons
df_comp_res_n <- df_comp_res_n %>% 
  filter(mod_a < mod_b)

# write_rds(df_comp_res_n, here::here("data/df_comp_res_narrow_1905.RDS"))
df_comp_res_n <- readRDS(here::here("data/df_comp_res_narrow_1905.RDS"))



```


Investigate nonconvergence:
```{r}
df_comp_res %>% 
  filter(is.na(emp)) %>% 
  count()    # no nonconvergence :-)

df_comp_res %>% 
  filter(is.na(emp)) %>% 
  group_by(comp, dgp, change, tp) %>% 
  count() %>% 
  View()

```




### Plotting Posterior Bootstrap approach
General plotting preparation
TODO: account for narrow priors!
```{r}
change_names <- c("change1.2" = paste("Largest", "\u00D7", "1.2"),
                  "change1.4" = paste("Largest", "\u00D7", "1.4"),
                  "change1.6" = paste("Largest", "\u00D7", "1.6"),
                  "const0.05" = paste("All", "\u00b1", "0.05"),
                  "const0.1" = paste("All", "\u00b1", "0.10"),
                  "const0.15" = paste("All", "\u00b1", "0.15"),
                  "permute" = "Permute"
)

graph_names <- c("Empirical\nSparse" = "graph3",
                 "Simulated\nChain" = "graph4",
                 "Simulated\nNonsparse" = "graph5")

norm_names <- c("frob" = "Frobenius",
                "l1" = "\u2113[1]",
                "maxdiff" = "Maxdiff")

tp_levels <- c("50" = "1", "100" = "2", "200" = "3", "400" = "4", "1000" = "5")

# Restructure results for proper plotting
df_comp_res <- df_comp_res %>% 
  mutate(comp = as.factor(comp)) %>% 
  mutate(comp = forcats::fct_relevel(comp, "l1")) %>% 
  mutate(change = gsub("permute134256", "permute", change))

# Delete old conditions
df_comp_res <- df_comp_res %>% 
  dplyr::filter(!grepl("noise", change))



```










#### Posterior Diff > Empirical

Do this in one plot:
```{r}
plot_test_distribution <- df_comp_res %>% 
          dplyr::filter(dgp %in% c("graph3", "graph4", "graph5")) %>% 
          dplyr::filter(change != "change1.2") %>% 
          # mutate tp_ind into factor
          mutate(tp = as.factor(tp)) %>% 
          mutate(tp = forcats::fct_relevel(tp, "50", "100", "200", "400", "1000")) %>% 
          mutate(dgp = case_match(dgp,
                                  "graph3" ~ "Empirical Sparse",
                                  "graph4" ~ "Simulated Chain",
                                  "graph5" ~ "Simulated Nonsparse")) %>% 
          pivot_longer(cols = c("beta_a", "beta_b", "pcor_a", "pcor_b"), 
                       names_to = "res", values_to = "value") %>% 
          group_by(comp, tp, change, dgp, res) %>% 
          # we have 1000 draws, so divide by 1000
          dplyr::summarize(pct_larger = value/1000) %>%  
          dplyr::summarize(pct_larger = mean(pct_larger)) %>% 
          ggplot(aes(x = tp, y = pct_larger, col = comp)) + 
          # geom_text(aes(label = round(pct_larger,1)), size = 4)+
          geom_line()+
          ggh4x::facet_nested(change ~ dgp + res)+
          theme_compare()+
          ggokabeito::scale_color_okabe_ito()+ 
          labs(
               x = "Timepeoints",
               y = "% larger than empirical")

plot_test_distribution


```

Do this with uncertainty
```{r}
plot_test_distribution_box <- df_comp_res %>% 
          dplyr::filter(dgp %in% c("graph3", "graph4", "graph5")) %>% 
          dplyr::filter(change != "change1.2") %>% 
          # mutate tp_ind into factor
          mutate(tp = as.factor(tp)) %>% 
          mutate(tp = forcats::fct_relevel(tp, "50", "100", "200", "400", "1000")) %>% 
          mutate(dgp = case_match(dgp,
                                  "graph3" ~ "Empirical Sparse",
                                  "graph4" ~ "Simulated Chain",
                                  "graph5" ~ "Simulated Nonsparse")) %>% 
          pivot_longer(cols = c("beta_a", "beta_b", "pcor_a", "pcor_b"), 
                       names_to = "res", values_to = "value") %>% 
          group_by(comp, tp, change, dgp, res) %>% 
          # we have 1000 draws, so divide by 1000
          dplyr::summarize(pct_larger = value/1000) %>%  
          # ignore model a and b because they are almost identical in distribution
          mutate(res = gsub("_.", "", res)) %>% 
          dplyr::mutate(res = case_match(res,
                                         "beta" ~ "Temporal",
                                         "pcor" ~ "Contemporaneous")) %>%
          ggplot(aes(x = tp, y = pct_larger, col = comp)) + 
          # geom_text(aes(label = round(pct_larger,1)), size = 4)+
          geom_boxplot(outlier.size = 0.5, outlier.alpha = 0.4, outlier.color = "grey")+
          ggh4x::facet_nested(change ~ dgp + res)+
          theme_compare()+
          ggokabeito::scale_color_okabe_ito()+ 
          labs(
               x = "Timepeoints",
               y = "% larger than empirical")

plot_test_distribution_box
ggsave(filename = "plot_test_distribution_box.svg",plot_test_distribution_box, device = "svg",
         path = here::here("figures/"), width = 14, height = 10)
```






Distribution of values under the null for the frobenius norm only.
```{r}
plot_test_null_dist <- df_comp_res %>% 
          dplyr::filter(dgp %in% c("graph3", "graph4", "graph5")) %>% 
          dplyr::filter(change == "truegraph") %>% 
          dplyr::filter(comp == "frob") %>% 
          # mutate tp into factor
          mutate(tp = as.factor(tp)) %>% 
          mutate(tp = forcats::fct_relevel(tp, "50", "100", "200", "400", "1000")) %>% 
          mutate(dgp = case_match(dgp,
                                  "graph3" ~ "Empirical Sparse",
                                  "graph4" ~ "Simulated Chain",
                                  "graph5" ~ "Simulated Nonsparse")) %>% 
          pivot_longer(cols = c("beta_a", "beta_b", "pcor_a", "pcor_b"), 
                       names_to = "res", values_to = "value") %>% 
          group_by(comp, tp, change, dgp, res) %>% 
          # we have 1000 draws, so divide by 1000 for proportion
          dplyr::summarize(pct_larger = value/1000) %>%  
          # ignore model a and b because they are almost identical in distribution
          mutate(res = gsub("_.", "", res)) %>% 
          dplyr::mutate(res = case_match(res,
                                         "beta" ~ "Temporal",
                                         "pcor" ~ "Contemporaneous")) %>%
          ggplot(aes(x = pct_larger)) + 
          # geom_text(aes(label = round(pct_larger,1)), size = 4)+
          geom_histogram(bins = 100, fill = ggokabeito::palette_okabe_ito()[2])+
          ggh4x::facet_nested(tp ~ dgp + res)+
          theme_compare()+
          ggokabeito::scale_color_okabe_ito()+ 
          labs(caption = "Frobenius norm only",
               x = "p-value",
               y = "")+
          scale_y_continuous(labels = NULL)

plot_test_null_dist
ggsave(filename = "plot_test_null_dist.svg",plot_test_null_dist, device = "svg",
         path = here::here("figures/"), width = 14, height = 10)

  
```









### Decision Rule
What happens to power/false positives if we implement the following decision rule:
If either A or B are "significant", we have evidence for a difference in the networks.



Decision Rule into one plot.
```{r}
plot_dec_rule <- df_comp_res %>% 
          dplyr::filter(dgp %in% c("graph3", "graph4", "graph5")) %>% 
          dplyr::filter(change != "change1.2") %>% 
          # mutate tp_ind into factor
          mutate(tp = as.factor(tp)) %>% 
          mutate(tp = forcats::fct_relevel(tp, "50", "100", "200", "400", "1000")) %>% 
          mutate(dgp = case_match(dgp,
                                  "graph3" ~ "Empirical Sparse",
                                  "graph4" ~ "Simulated Chain",
                                  "graph5" ~ "Simulated Nonsparse")) %>% 
          # setup decision rule
          dplyr::mutate(sig_beta05 = ifelse(beta_a < 50 | beta_b < 50, 1, 0),
                 sig_pcor05 = ifelse(pcor_a < 50 | pcor_b < 50, 1, 0)) %>% 
          dplyr::group_by(dgp, comp, tp, change) %>% 
          dplyr::mutate(n_comp = n()) %>% 
          dplyr::summarize(power_beta05 = sum(sig_beta05)/n_comp,
                    power_pcor05 = sum(sig_pcor05)/n_comp) %>% 
          # somehow does not cut everything if I don't do this
          # TODO
          dplyr::summarize(power_beta05 = mean(power_beta05),
                    power_pcor05 = mean(power_pcor05)) %>% 
          tidyr::pivot_longer(cols = c("power_beta05", "power_pcor05"), names_to = "res") %>%
          dplyr::mutate(res = case_match(res,
                                         "power_beta05" ~ "Temporal",
                                         "power_pcor05" ~ "Contemporaneous")) %>% 
          ggplot(aes(x = tp, y = value, col = comp, group = comp)) + 
          geom_line()+
          ggh4x::facet_nested(change ~ dgp + res, scales = "free_y",
                             strip = strip_nested(background_y = list(
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                element_rect(colour = "grey")
                             )))+

          # leave this out and delete scales argument above to switch to old plot
          ggh4x::facetted_pos_scales(y = list(
            scale_y_continuous(breaks = c(0,0.25, 0.5, 0.75, 1)),
            scale_y_continuous(breaks = c(0,0.25, 0.5, 0.75, 1)),
            scale_y_continuous(breaks = c(0,0.25, 0.5, 0.75, 1)),
            scale_y_continuous(breaks = c(0,0.25, 0.5, 0.75, 1)),
            scale_y_continuous(breaks = c(0,0.25, 0.5, 0.75, 1)),
            scale_y_continuous(breaks = c(0,0.25, 0.5, 0.75, 1)),
            scale_y_continuous(limits = c(0,0.1), guide = guide_axis(title = "rescaled"))
          ))+
          theme_compare()+
          ggokabeito::scale_colour_okabe_ito()+
          labs(caption = paste0("Power of decision rule \"OR\" at 5% level"),
               x = "Timepoints",
               y = "Power",
               col = "Norm")+
            theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
          strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

plot_dec_rule
ggsave(filename = "plot_dec_rule_new.svg",plot_dec_rule, device = "svg",
         path = here::here("figures/"), width = 13, height = 15)

```


New decision rule plot without truegraph
```{r}
plot_dec_rule <- df_comp_res %>% 
          dplyr::filter(dgp %in% c("graph3", "graph4", "graph5")) %>% 
          dplyr::filter(change != "change1.2") %>% 
          dplyr::filter(change != "truegraph") %>% 
          # mutate tp_ind into factor
          mutate(tp = as.factor(tp)) %>% 
          mutate(tp = forcats::fct_relevel(tp, "50", "100", "200", "400", "1000")) %>% 
          mutate(dgp = case_match(dgp,
                                  "graph3" ~ "Empirical Sparse",
                                  "graph4" ~ "Simulated Chain",
                                  "graph5" ~ "Simulated Nonsparse")) %>% 
          # setup decision rule
          dplyr::mutate(sig_beta05 = ifelse(beta_a < 50 | beta_b < 50, 1, 0),
                 sig_pcor05 = ifelse(pcor_a < 50 | pcor_b < 50, 1, 0)) %>% 
          dplyr::group_by(dgp, comp, tp, change) %>% 
          dplyr::mutate(n_comp = n()) %>% 
          dplyr::summarize(power_beta05 = sum(sig_beta05)/n_comp,
                    power_pcor05 = sum(sig_pcor05)/n_comp) %>% 
          # somehow does not cut everything if I don't do this
          # TODO
          dplyr::summarize(power_beta05 = mean(power_beta05),
                    power_pcor05 = mean(power_pcor05)) %>% 
          tidyr::pivot_longer(cols = c("power_beta05", "power_pcor05"), names_to = "res") %>%
          dplyr::mutate(res = case_match(res,
                                         "power_beta05" ~ "Temporal",
                                         "power_pcor05" ~ "Contemp.")) %>% 
          ggplot(aes(x = tp, y = value, col = comp, group = comp)) + 
          geom_line()+
          theme_compare()+
          ggh4x::facet_nested(change ~ dgp + res)+
          ggokabeito::scale_colour_okabe_ito()+
          labs(x = "Timepoints",
               y = "Power",
               col = "Norm")+
            theme(
                  strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2),
                  hjust = 0.5),
                  strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2),
                  hjust = 0.5),
                  legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
                  legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
                  # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
                  panel.spacing.y = ggplot2::unit(1.6, "lines"),
                  panel.spacing.x = ggplot2::unit(1.6, "lines"),
                  axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.05)),
                  axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3)),
                  axis.title.y = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3)))

plot_dec_rule
ggsave(filename = "plot_dec_rule.svg",plot_dec_rule, device = "svg",
         path = here::here("figures/"), width = 12, height = 12)
```


Now with uncertainty in the form of standard errors. 
```{r}
# Number of combinations
n_comp <- 4950

plot_dec_rule_se <- df_comp_res %>% 
          dplyr::filter(dgp %in% c("graph3", "graph4", "graph5")) %>% 
          dplyr::filter(change != "change1.2") %>% 
          dplyr::filter(change != "truegraph") %>% 
          # mutate tp_ind into factor
          dplyr::mutate(tp = as.factor(tp)) %>% 
          dplyr::mutate(tp = forcats::fct_relevel(tp, "50", "100", "200", "400", "1000")) %>% 
          dplyr::mutate(dgp = fct_recode(as_factor(as.character(dgp)), !!!graph_names)) %>% 
          dplyr::mutate(change = case_match(
            change,
                  "change1.2" ~ paste("Largest", "\u00D7", "1.2"),
                  "change1.4" ~ paste("Largest", "\u00D7", "1.4"),
                  "change1.6" ~ paste("Largest", "\u00D7", "1.6"),
                  "const0.05" ~ paste("All", "\u00b1", "0.05"),
                  "const0.1" ~ paste("All", "\u00b1", "0.10"),
                  "const0.15" ~ paste("All", "\u00b1", "0.15"),
                  "permute" ~ "Permute"
          )) %>% 
          dplyr::mutate(change = as.factor(change)) %>% 
          dplyr::mutate(change = forcats::fct_relevel(change, "Largest √ó 1.4", 
                                                      "Largest √ó 1.6",
                                                      "All ¬± 0.05",
                                                      "All ¬± 0.10",
                                                      "All ¬± 0.15")) %>% 
          # mutate(change = fct_recode(as_factor(as.character(change)), !!!change_names)) %>% 
          # setup decision rule
          dplyr::mutate(
                 sig_beta05 = ifelse(beta_a < 50 | beta_b < 50, 1, 0),
                 sig_pcor05 = ifelse(pcor_a < 50 | pcor_b < 50, 1, 0)) %>% 
          dplyr::group_by(dgp, comp, tp, change) %>% 
          dplyr::summarize(
                    power_beta05 = sum(sig_beta05)/n_comp,
                    power_pcor05 = sum(sig_pcor05)/n_comp,
                    se_beta05 = sqrt((power_beta05 * (1-power_beta05))/100),
                    se_pcor05 = sqrt((power_pcor05 * (1-power_pcor05))/100)) %>% 
          tidyr::pivot_longer(cols = c("power_beta05", "power_pcor05"), names_to = "res") %>%
          # attach correct se
          dplyr::mutate(se = ifelse(grepl("beta", res), se_beta05, se_pcor05)) %>% 
          dplyr::select(!c(se_beta05, se_pcor05)) %>% 
          dplyr::mutate(mat = case_when(
            grepl("beta05", res) ~ "Temporal",
            grepl("pcor05", res) ~ "Contemporaneous")) %>% 
          ggplot(aes(x = tp, y = value, col = comp, group = comp)) + 
          geom_point(position = position_dodge(0.3), size = 0.5)+
          geom_line()+
          geom_linerange(aes(ymin = value - 1.96*se, x = tp,
                            ymax = value + 1.96*se),
                        width = .5, position = position_dodge(0.3))+
          theme_compare()+
          ggh4x::facet_nested(change ~ dgp + mat,
                              axes = TRUE)+
          ggokabeito::scale_colour_okabe_ito()+
          labs(x = "Timepoints",
               y = "Power",
               col = "Norm")+
            theme(
                  strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2),
                  hjust = 0.5),
                  strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2),
                  hjust = 0.5),
                  legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
                  legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
                  # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
                  panel.spacing.y = ggplot2::unit(1.6, "lines"),
                  panel.spacing.x = ggplot2::unit(1.6, "lines"),
                  axis.line = element_line(),
                  axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.05)),
                  axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3)),
                  axis.title.y = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3)))

plot_dec_rule_se
ggsave(filename = "plot_dec_rule_se_axes.svg",plot_dec_rule_se, device = "svg", path = here::here("figures/"), width = 14, height = 12)
```




#### False Positives

In one graph:
```{r}
plot_false_positive <- df_comp_res %>%
          dplyr::filter(dgp %in% c("graph3", "graph4", "graph5")) %>%
          filter(change == "truegraph") %>%
          # setup decision rule
          mutate(sig_beta05 = ifelse(beta_a < 50 | beta_b < 50, 1, 0),
                 sig_pcor05 = ifelse(pcor_a < 50 | pcor_b < 50, 1, 0)) %>%
          # mutate tp_ind into factor
          mutate(tp = as.factor(tp)) %>%
          mutate(tp = forcats::fct_relevel(tp, "50", "100", "200", "400", "1000")) %>%
          dplyr::mutate(dgp = fct_recode(as_factor(as.character(dgp)), !!!graph_names)) %>% 
          group_by(dgp, comp, tp, change) %>%
          mutate(n_comp = n()) %>%
          summarize(fp_beta05 = sum(sig_beta05)/n_comp,
                    fp_pcor05 = sum(sig_pcor05)/n_comp) %>%
          # somehow does not cut everything if I don't do this
          # TODO
          summarize(fp_beta05 = mean(fp_beta05),
                    fp_pcor05 = mean(fp_pcor05)) %>%
          rename("Temporal" = fp_beta05,
                 "Contemporaneous" = fp_pcor05) %>%
          pivot_longer(cols = c("Temporal", "Contemporaneous"), names_to = "res") %>%
          ggplot(aes(x = tp, y = value, col = comp, group = comp)) +
          geom_line()+
          ggh4x::facet_nested(. ~ dgp + res)+
          theme_minimal()+
          ylim(0,.1)+
          ggokabeito::scale_color_okabe_ito()+
          theme_compare()+
          geom_hline(yintercept = 0.05, col = "#D5D8DC")+ 
          labs(caption = paste0(x = "Timepoints", 
               col = "Norm",
               y = "Proportion of false positives"))+
              theme(
                  strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2),
                  hjust = 0.5),
                  strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2),
                  hjust = 0.5),
                  legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
                  legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
                  # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
                  panel.spacing.y = ggplot2::unit(1.6, "lines"),
                  panel.spacing.x = ggplot2::unit(1.6, "lines"),
                  axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.05)),
                  axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3)),
                  axis.title.y = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3)))

plot_false_positive
ggsave(filename = paste0("plot_false_positive.svg"),plot_false_positive, device = "svg",
         path = here::here("figures/"), width = 12, height = 6)


```


With uncertainty:
```{r}
plot_false_positive_box <- df_comp_res %>%
          dplyr::filter(dgp %in% c("graph3", "graph4", "graph5")) %>%
          filter(change == "truegraph") %>%
          # setup decision rule
          mutate(sig_beta05 = ifelse(beta_a < 50 | beta_b < 50, 1, 0),
                 sig_pcor05 = ifelse(pcor_a < 50 | pcor_b < 50, 1, 0)) %>%
          # mutate tp_ind into factor
          mutate(tp = as.factor(tp)) %>%
          mutate(tp = forcats::fct_relevel(tp, "50", "100", "200", "400", "1000")) %>%
          dplyr::mutate(dgp = fct_recode(as_factor(as.character(dgp)), !!!graph_names)) %>% 
          
          # setup decision rule
          dplyr::mutate(
                 sig_beta05 = ifelse(beta_a < 50 | beta_b < 50, 1, 0),
                 sig_pcor05 = ifelse(pcor_a < 50 | pcor_b < 50, 1, 0)) %>% 
          dplyr::group_by(dgp, comp, tp, change) %>% 
          dplyr::summarize(
                    power_beta05 = sum(sig_beta05)/n_comp,
                    power_pcor05 = sum(sig_pcor05)/n_comp,
                    se_beta05 = sqrt((power_beta05 * (1-power_beta05))/100),
                    se_pcor05 = sqrt((power_pcor05 * (1-power_pcor05))/100)) %>% 
          tidyr::pivot_longer(cols = c("power_beta05", "power_pcor05"), names_to = "res") %>%
          # attach correct se
          dplyr::mutate(se = ifelse(grepl("beta", res), se_beta05, se_pcor05)) %>% 
          dplyr::select(!c(se_beta05, se_pcor05)) %>% 
          dplyr::mutate(mat = case_when(
            grepl("beta05", res) ~ "Temporal",
            grepl("pcor05", res) ~ "Contemp.")) %>% 
          ggplot(aes(x = tp, y = value, col = comp, group = comp)) +
          geom_point(position = position_dodge(0.3), size = 0.5)+
          geom_line()+
          geom_linerange(aes(ymin = value - 1.96*se, x = tp,
                            ymax = value + 1.96*se),
                        width = .5, position = position_dodge(0.3))+
          ggh4x::facet_nested(. ~ dgp + mat)+
          theme_minimal()+
          ylim(-0.1,.2)+
          ggokabeito::scale_color_okabe_ito()+
          theme_compare()+
          geom_hline(yintercept = 0.05, col = "#D5D8DC")+ 
          labs(x = "Timepoints", 
               col = "Norm",
               y = "Proportion of false positives")+
              theme(
                  strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2),
                  hjust = 0.5),
                  strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2),
                  hjust = 0.5),
                  legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
                  legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
                  # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
                  panel.spacing.y = ggplot2::unit(1.6, "lines"),
                  panel.spacing.x = ggplot2::unit(1.6, "lines"),
                  axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.05)),
                  axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3)),
                  axis.title.y = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3)))

plot_false_positive_box
ggsave(filename = paste0("plot_false_positive_box.svg"),plot_false_positive_box, device = "svg",
         path = here::here("figures/"), width = 13, height = 6)
```





### Prior sensitivity graph
To keep everything clearer visually, we only use one norm (Frobenius) for now. 
```{r}
plot_dec_rule_prior_sens <- df_comp_res %>% 
          dplyr::filter(comp == "frob") %>% 
          dplyr::filter(dgp %in% c("graph3", "graph4", "graph5",
                                   "narrow_graph3", "narrow_graph4", "narrow_graph5")) %>% 
          dplyr::filter(change != "change1.2") %>% 
          mutate(dgp = case_match(dgp,
                                  "graph3" ~ "wide_graph3",
                                  "graph4" ~ "wide_graph4",
                                  "graph5" ~ "wide_graph5",
                                  .default = dgp)) %>% 
          # mutate tp_ind into factor
          mutate(tp = as.factor(tp)) %>% 
          mutate(tp = forcats::fct_relevel(tp, "50", "100", "200", "400", "1000")) %>% 
          # separate graph and prior
          tidyr::separate_wider_delim(cols = dgp, delim = "_", names = c("prior", "dgp")) %>% 
          mutate(dgp = case_match(dgp,
                                  "graph3" ~ "Empirical Sparse",
                                  "graph4" ~ "Simulated Chain",
                                  "graph5" ~ "Simulated Nonsparse")) %>%
          # setup decision rule
          dplyr::mutate(sig_beta05 = ifelse(beta_a < 50 | beta_b < 50, 1, 0),
                 sig_pcor05 = ifelse(pcor_a < 50 | pcor_b < 50, 1, 0)) %>% 
          dplyr::group_by(dgp, comp, prior, tp, change) %>% 
          dplyr::summarize(
                    power_beta05 = sum(sig_beta05)/n_comp,
                    power_pcor05 = sum(sig_pcor05)/n_comp,
                    se_beta05 = sqrt((power_beta05 * (1-power_beta05))/100),
                    se_pcor05 = sqrt((power_pcor05 * (1-power_pcor05))/100)) %>% 
          tidyr::pivot_longer(cols = c("power_beta05", "power_pcor05"), names_to = "res") %>%
          # attach correct se
          dplyr::mutate(se = ifelse(grepl("beta", res), se_beta05, se_pcor05)) %>% 
          dplyr::select(!c(se_beta05, se_pcor05)) %>% 
          dplyr::mutate(mat = case_when(
            grepl("beta05", res) ~ "Temporal",
            grepl("pcor05", res) ~ "Contemp.")) %>%  
          ggplot(aes(x = tp, y = value, col = prior, group = prior)) + 
          geom_point(position = position_dodge(0.1), size = 0.5)+
          geom_line()+
          geom_linerange(aes(ymin = value - 1.96*se, x = tp,
                            ymax = value + 1.96*se),
                        width = .5, position = position_dodge(0.1))+
          ggh4x::facet_nested(change ~ dgp + mat)+
          ggokabeito::scale_colour_okabe_ito()+
          theme_compare()+
          labs(caption = paste0("Power of decision rule \"OR\" at 5% level"),
               x = "Timepoints",
               y = "Power",
               col = "Prior")


plot_dec_rule_prior_sens
ggsave(filename ="plot_dec_rule_prior_sens.svg",plot_dec_rule_prior_sens, device = "svg",
         path = here::here("figures/"), width = 13, height = 10)
```








### Norms across conditions
How large are the norms across the simulation conditions?
```{r}
v_graphs <- c("graph1", "graph2", "graph3", "graph4", "graph5", "graph6")

for(g in v_graphs){
  
  p <- df_comp_res %>% 
        filter(dgp == g) %>% 
        mutate(comp = as.factor(comp),
               tp = as.numeric(tp),
               change = as.factor(change),
               emp  = as.numeric(emp)) %>% 
        group_by(comp, dgp, change, tp) %>% 
        summarize(mean_emp = mean(emp),
                  sd_emp = sd(emp)) %>%
        ggplot(aes(x = as.numeric(tp), y = mean_emp, col = comp))+
        geom_line()+
        geom_ribbon(aes(ymin = mean_emp - sd_emp, ymax = mean_emp + sd_emp, fill = comp), 
                    alpha = 0.4, colour = NA)+
        ggh4x::facet_grid2(change ~ comp, scales = "free", independent = "y")+
        theme_minimal()+
        scale_color_okabe_ito()+
        scale_fill_okabe_ito()+
        labs(caption = g,
             x = "Timepoints",
             y = "Mean Distance")

  
  ggsave(filename = paste0("plot_emp_norms_", g, ".svg"),p, device = "svg",
         path = here("figures/"))
  print(p)
}
```






