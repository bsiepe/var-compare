---
title: "bggm-var-investigation"
author: "Bj√∂rn Siepe"
date: "2022-11-18"
output: html_document
---



```{r}
library(tidyverse)
library(doParallel)
library(parallel)
library(foreach)
library(BGGM)
library(graphicalVAR)
library(cowplot)
library(sysfonts)
source("aux_funs.R")

seed = 2022
set.seed(seed)
```




# Simulation study

## Data Generation


Simulate data anew.
```{r}
# Simulation conditions
n_ind <- 1000 # number of individuals(so models to create) 
n_tp <- c(50,100,200,400,1000) # number of timepoints
n_postds <- 1000 # number of datasets per condition
seed <- 2022
dgp_names <- c("graph1", "graph2", "graph3", "graph4", "graph5", "graph6")






# Think about if I actually need to standardize here
# because everything will be standardized by var_estimate anyway
l_raw <- readRDS(l_raw, file = here::here("data/l_raw1000.RDS"))


set.seed(seed)
before_simraw <- Sys.time()
ncores = 40
cl = makeCluster(ncores)
registerDoParallel(cl)
l_raw <- list()
l_raw$graph6 <- l_raw$graph5 <- l_raw$graph4 <- l_raw$graph3 <- l_raw$graph2 <- l_raw$graph1 <-  list()
for(dgp in dgp_names){
  for(t in seq_along(n_tp)){
  l_raw[[dgp]][[t]] <- list()
  l_raw[[dgp]][[t]] <- sim_raw_parallel(dgp = l_graphs[[dgp]],
                                    n = n_postds,
                                    tp = n_tp[t],
                                    seed = seed,
                                    means = 0,
                                    standardize = TRUE)

}
}


stopCluster(cl)


# saveRDS(l_raw, file = here::here("data/l_raw1000.RDS"))



```





## Estimation
Estimate both graphicalVAR in default settings as well as BGGM with varying priors.

Next steps here: load results, then figure out which files haven't been done yet
```{r}
# Priors
dgp <- c(1,2,3,4,5,6)
rho_sd <- c(0.1, 0.3, 0.5)
beta_sd <- c(0.2, 0.5, 1)
n_tp <- c(50, 100, 200, 400, 1000) 
tp_cond <- c(1,2,3,4,5)   # different tp conditions

cond_grid <- expand.grid(dgp = dgp,
                         n_tp = tp_cond,
                         rho_prior = rho_sd, 
                         beta_prior = beta_sd)
n_iter <- 50000
seed <- 2022
set.seed(seed)



# Estimating for each model 
# store BGGM results under "nonselect"
ncores = 50
cl = makeCluster(ncores)
clusterExport(cl = cl, "summarize_post")
registerDoParallel(cl)
l_res_bggm <- list()



for(n in 1:nrow(cond_grid)) {
  dgp_ind <- as.numeric(cond_grid[n, "dgp"])
  tp_ind <- as.numeric(cond_grid[n, "n_tp"])
  r_sd <- as.numeric(cond_grid[n, "rho_prior"])
  b_sd <- as.numeric(cond_grid[n, "beta_prior"])
  print(paste0(nrow(cond_grid)-n, " to go!"))
  l_res_bggm[[n]]  <- fit_var_parallel_merged(l_raw[[dgp_ind]][[tp_ind]],
                          rho_prior = r_sd,
                          beta_prior = b_sd,
                          iterations = n_iter,
                          n = 1000,
                          nds = 1000,
                          seed = seed,
                          get_kappa = FALSE, 
                          summarize_post = TRUE,
                          cred_int = c(0.9, 0.95, 0.99),
                          pruneresults = FALSE,
                          save_files = FALSE,
                          multigroup = FALSE,
                          select = TRUE)
    

  
}
stopCluster(cl)

# Attach the simulation conditions
for(m in 1:nrow(cond_grid)){
  for(i in 1:length(l_res_bggm[[m]])){
    l_res_bggm[[m]][[i]]$sim_cond <- cond_grid[m,]
  }
}

saveRDS(l_res_bggm, here::here("output/bggm-var-sim-res_2403.Rds"))
# l_res_bggm <- readRDS(here::here("output/bggm-var-sim-res_1703.Rds"))



```
### Fit graphicalVAR
```{r}
# Conditions of varying sparsity
gamma_ebic <- c(0, 0.5)      # EBIC hyperparameter
lambda <- c(NA, 0)


cond_grid_gvar <- expand.grid(dgp = dgp,
                         n_tp = tp_cond,
                         gamma_ebic = gamma_ebic,
                         lambda = lambda)


ncores = 50
cl = makeCluster(ncores)
clusterExport(cl = cl, "fit_graphicalvar_parallel")
registerDoParallel(cl)
l_res_gvar <- list()
time_before_gvar <- Sys.time()
for(n in 1:nrow(cond_grid_gvar)) {
  dgp_ind <- as.numeric(cond_grid_gvar[n, "dgp"])
  tp_ind <- as.numeric(cond_grid_gvar[n, "n_tp"])
  gamma_ebic <- as.numeric(cond_grid_gvar[n, "gamma_ebic"])
  lambda <- as.numeric(cond_grid_gvar[n, "lambda"])
  print(paste0(nrow(cond_grid_gvar)-n, " to go!"))
  
  # unregularized
  if(!is.na(lambda)){
   l_res_gvar[[n]]  <- fit_graphicalvar_parallel(l_raw[[dgp_ind]][[tp_ind]],
                                                  n = 1000,
                                                  gamma = gamma_ebic,
                                                  nLambda = 50, 
                                                  pruneresults = TRUE, 
                                                  lambda_beta = lambda,
                                                  lambda_kappa = lambda)
                            
  }
  # regularized
  if(is.na(lambda)){
   l_res_gvar[[n]]  <- fit_graphicalvar_parallel(l_raw[[dgp_ind]][[tp_ind]],
                                                 n = 1000,
                                                 gamma = gamma_ebic,
                                                 nLambda = 50, 
                                                 pruneresults = TRUE)
    
  }
    

  
}
stopCluster(cl)

time_after_gvar <- Sys.time() - time_before_gvar


# Attach the simulation conditions
for(m in 1:nrow(cond_grid_gvar)){
  for(i in 1:length(l_res_gvar[[m]])){
    l_res_gvar[[m]][[i]]$sim_cond <- cond_grid_gvar[m,]
  }
}

# saveRDS(l_res_gvar, here::here("output/graphicalvar-sim-res_2403.Rds"))
# l_res_gvar <- readRDS(here::here("output/graphicalvar-sim-res_1703.Rds"))

    



```




## Evaluation
Evaluate both with and without graph selection.

```{r}
l_res_bggm <- readRDS(here::here("output/bggm-var-sim-res_2403.Rds"))
l_res_gvar <- readRDS(here::here("output/graphicalvar-sim-res_2403.Rds"))
l_graphs <- readRDS(here::here("data/l_graphs.RDS"))


## BGGM
l_eval_bggm <- lapply(l_res_bggm, function(x){
  res <- lapply(x, eval_bggm)
  return(res)
})

rm(l_res_bggm)
df_eval_bggm <- purrr::flatten(l_eval_bggm)
df_eval_bggm <- dplyr::bind_rows(df_eval_bggm)
# Pivot CIs wider
df_eval_bggm_wide <- df_eval_bggm %>% 
  tidyr::unpack(cols = ci) %>% 
  pivot_wider(names_from = ci, values_from = c(sum_cover_beta, sum_cover_pcor,
                                               width_beta, width_pcor))
rm(df_eval_bggm)
rm(l_eval_bggm)
df_eval_bggm <- df_eval_bggm_wide
rm(df_eval_bggm_wide)


## GVAR
l_eval_gvar <- list()
for(i in 1:nrow(cond_grid_gvar)){
  l_eval_gvar[[i]] <- lapply(l_res_gvar[[i]], eval_gvar)
}

# Convert to dataframe
df_eval_gvar <- purrr::flatten(l_eval_gvar)
df_eval_gvar <- dplyr::bind_rows(df_eval_gvar)
rm(l_eval_gvar)

# save evaluations
# saveRDS(df_eval_gvar, here::here("output/df_eval_gvar_2703.RDS"))
# saveRDS(df_eval_bggm, here::here("output/df_eval_bggm_2703.RDS"))
df_eval_gvar <- readRDS(here::here("output/df_eval_gvar_2703.RDS"))
df_eval_bggm <- readRDS(here::here("output/df_eval_bggm_2703.RDS"))

```



### Plotting results

Prepare plotting
```{r}
# Timepoint values with all levels
tp_levels <- c("50" = "1", "100" = "2", "200" = "3", "400" = "4", "1000" = "5")

# DGP cut: should old dgps be cut? then set this to 2
# if not, set to 0
dgp_cut <- 2

# DGP Names
dgp_levels <- c("Old1" = "1", "Old2" = "2", "Empirical\nSparse" = "3",
                 "Simulated\nChain 6N" = "4", "Simulated\nNonsparse" = "5",
                 "Simulated\nChain 8N" = "6")

# With deleting old DGPs
dgp_levels <- c("Empirical\nSparse" = "3",
                 "Simulated\nChain 6N" = "4", "Simulated\nNonsparse" = "5",
                 "Simulated\nChain 8N" = "6")

```


#### Plot BGGM
```{r}
df_eval_bggm_summary <- df_eval_bggm %>% 
  filter(dgp > dgp_cut) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  group_by(dgp_ind, tp_ind, rho_prior, beta_prior) %>% 
  # convert coverage into proportion
  mutate(n_nodes = ifelse(dgp_ind == 6, 8, 6)) %>% 
  mutate(across(contains("sum_cover_beta"),
                ~ ./n_nodes^2)) %>% 
  # divide by number of unique off-diagonal elements
  mutate(across(contains("sum_cover_pcor"),
                ~ ./((n_nodes/2)*(n_nodes-1)))) %>% 
  summarize(across(c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                   bias_beta_sel, bias_pcor_sel, cor_beta_sel,                                    cor_pcor_sel, spec_beta, spec_pcor,
                   sens_beta, sens_pcor, contains("sum_cover")), 
                   .fns = list(mean = mean, 
                               sd = sd,
                               # se = ~ sd / sqrt(1000),
                               # lower = ~ mean - 1.96*se, 
                               # upper = ~ mean + 1.96*se, 
                               median = ~ median(.x, na.rm = TRUE))))

df_eval_bggm_long <- df_eval_bggm %>% 
  filter(dgp > dgp_cut) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  group_by(dgp_ind, tp_ind, rho_prior, beta_prior) %>% 
  # convert coverage into proportion
  mutate(n_nodes = ifelse(dgp_ind == 6, 8, 6)) %>% 
  mutate(across(contains("sum_cover_beta"),
                ~ ./n_nodes^2)) %>% 
  # divide by number of unique off-diagonal elements
  mutate(across(contains("sum_cover_pcor"),
                ~ ./((n_nodes/2)*(n_nodes-1)))) %>% 
  summarize(across(c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                   bias_beta_sel, bias_pcor_sel, cor_beta_sel, cor_pcor_sel, spec_beta, spec_pcor,
                   sens_beta, sens_pcor, contains("sum_cover")), 
                   ~mean(.))) %>% 
  pivot_longer(cols = c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                   bias_beta_sel, bias_pcor_sel, cor_beta_sel, cor_pcor_sel, spec_beta, spec_pcor,
                   sens_beta, sens_pcor, contains("sum_cover")), names_to = "stat", 
               values_to = "value") %>% 
  mutate(prior_comb = paste0(expression(rho)," = ", rho_prior,", ", expression(beta)," = ", beta_prior)) %>% 
  ungroup() 
  
  
plot_eval_bggm <- df_eval_bggm_long %>% 
  ggplot(aes(x = tp_ind, y = value, col = prior_comb, group = prior_comb)) + 
  facet_grid(dgp_ind ~ stat) + 
  geom_line() + 
  theme_bw()+
  theme_compare()+
  labs(x = "Timepoints",
       col = "Priors")+
  # guides(color = guide_legend(col = parse(text = prior_comb)))+
  ylim(0,1)+
  ggokabeito::scale_color_okabe_ito()

ggsave("plot_eval_bggm.svg", plot_eval_bggm, path = here::here("figures/"), device = "svg", width = 30, height = 9)  


# Eval plot with boxplots
# TODO: Use less conditions
plot_eval_bggm_box <- df_eval_bggm %>% 
  filter(dgp > dgp_cut) %>% 
  group_by(dgp_ind, tp_ind, rho_prior, beta_prior) %>% 
  # convert coverage into proportion
  mutate(n_nodes = ifelse(dgp_ind == 6, 8, 6)) %>% 
  mutate(across(contains("sum_cover_beta"),
                ~ ./n_nodes^2)) %>% 
  # divide by number of unique off-diagonal elements
  mutate(across(contains("sum_cover_pcor"),
                ~ ./((n_nodes/2)*(n_nodes-1)))) %>% 
  # summarize(across(c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
  #                  bias_beta_sel, bias_pcor_sel, cor_beta_sel,                              cor_pcor_sel, spec_beta, spec_pcor,
  #                  sens_beta, sens_pcor, contains("sum_cover")), 
  #                  ~mean(.))) %>% 
  pivot_longer(cols = c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                   bias_beta_sel, bias_pcor_sel, cor_beta_sel, cor_pcor_sel, spec_beta, spec_pcor,
                   sens_beta, sens_pcor, contains("sum_cover")), names_to = "stat", 
               values_to = "value") %>% 
  mutate(prior_comb = paste0("rho = ", rho_prior, ", beta = ", beta_prior)) %>% 
  ungroup() %>% 
  ggplot(aes(x = tp_ind, y = value, col = prior_comb)) + 
  facet_grid(dgp_ind ~ stat) + 
  geom_boxplot(outlier.size = 0.5, outlier.alpha = 0.4, outlier.color = "grey") + 
  ylim(0,1)+
  ggokabeito::scale_color_okabe_ito()
plot_eval_bggm
ggsave("plot_eval_bggm_boxplot.svg", plot_eval_bggm_box, path = here::here("figures/"), device = "svg", width = 16, height = 9)  

```

### Plot GVAR
Plot results
```{r}
plot_eval_gvar <- df_eval_gvar %>% 
  filter(dgp > dgp_cut) %>% 
  dplyr::mutate(lambda = as.character(lambda)) %>% 
  dplyr::mutate(lambda = tidyr::replace_na(lambda, "default")) %>% 
  dplyr::group_by(dgp_ind, tp_ind, ebic, lambda) %>% 
  dplyr::summarize(across(c(bias_beta, bias_pcor, cor_beta, cor_pcor,
                     spec_beta, spec_pcor,
                     sens_beta, sens_pcor),
                   ~mean(.))) %>% 
  tidyr::pivot_longer(cols = (c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                         spec_beta, spec_pcor,
                         sens_beta, sens_pcor)), 
               names_to = "stat", values_to = "value") %>% 
  dplyr::mutate(ebic_lambda_comb = paste0("Gamma: ", ebic, ", Lambda = ", lambda)) %>% 
  ungroup() %>% 
  ggplot(aes(x = tp_ind, y = value, col = ebic_lambda_comb))+
  geom_line()+
  facet_grid(dgp_ind ~ stat) + 
  ylim(0,1)+
  theme_compare()+
  ggokabeito::scale_colour_okabe_ito()

ggsave("plot_eval_gvar.svg", plot_eval_gvar, path = here::here("figures/"), device = "svg", width = 16, height = 9)  

```



## Correlate BGGM and graphicalVAR

BGGM and GVAR simulations have different amount of conditions, so I need to match them on their DGP + number of time points first
```{r}
cond_grid_full <- cond_grid %>% 
  mutate(iter_bggm = dplyr::row_number()) %>% 
  left_join(cond_grid_gvar %>% mutate(iter_gvar = dplyr::row_number()),
            by = c("dgp", "n_tp"))

# loop through all conditions and compute correlations
l_cor <- list()
for(i in 1:nrow(cond_grid_full)){
  iter_bggm <- cond_grid_full[i, "iter_bggm"]
  iter_gvar <- cond_grid_full[i, "iter_gvar"]
  
  l_cor[[i]] <- mapply(compare_bggm_gvar, l_res_bggm[[iter_bggm]], l_res_gvar[[iter_gvar]], SIMPLIFY = FALSE)
  
  # add iteration information
  l_cor[[i]] <- lapply(l_cor[[i]], function(x){
    x$iter_bggm <- iter_bggm
    x$iter_gvar <- iter_gvar
    return(x)
  })
}

l_cor_flat <- flatten(l_cor)
df_cor <- dplyr::bind_rows(l_cor_flat)

# NAs are zeroes 
df_cor_full <- df_cor %>% 
  mutate(across(contains("cor"),
                ~tidyr::replace_na(., replace = 0))) %>% 
  left_join(cond_grid_full, by = c("iter_bggm", "iter_gvar"))


```



Visualize results across simulation conditions. 
This does not work :(
```{r}
df_cor_grid  <- df_cor_full %>% 
  filter(dgp > dgp_cut)
  dplyr::group_by(iter_bggm, iter_gvar) %>% 
  # this summarizes prior info etc., which is the same within a simulation condition
  # just a trick to keep it in the df
  dplyr::summarize(across(everything(),
                   ~mean(.))) %>% 
  tidyr::pivot_longer(cols = contains("cor"), values_to = "cor", names_to = "mat") %>% 
  dplyr::mutate(comb = paste0("R: ", rho_prior, ", B: ", beta_prior,
                       ", G: ", gamma_ebic, ", L : ", lambda)) %>% 
  dplyr::ungroup() %>% 
  ggplot(aes(x = as.factor(n_tp), y = cor, col = mat))+
  geom_line()+
  theme_bw()+
  facet_grid(dgp~comb)+
  # ggokabeito::scale_color_okabe_ito()+
  theme(strip.text.x = element_text(size = 3))


ggsave("df_cor_grid.svg", df_cor_grid, height = 5, width = 25, path = here::here("figures/"),
       device = "svg")


```

Divide correlation plot by gvar regularized vs. non-regularized
TODO: add diff_beta
```{r}
df_cor_grid_nonreg <- df_cor_full %>% 
  group_by(iter_bggm, iter_gvar) %>% 
  filter(dgp > dgp_cut) %>% 
  # this summarizes prior info etc., which is the same within a simulation condition
  # just a trick to keep it in the df
  dplyr::summarize(across(everything(),
                   ~mean(.))) %>% 
  pivot_longer(cols = c(contains("cor"), contains("diff")), values_to = "cor", names_to = "mat") %>%
  filter(is.na(lambda)) %>% 
  mutate(comb = paste0("R: ", rho_prior, ", B: ", beta_prior,
                       ", G: ", gamma_ebic)) %>% 
  # add linetype
  mutate(lty = ifelse(grepl("sel", mat), "select", "nonselect")) %>% 
  ungroup() %>% 
  ggplot(aes(x = n_tp, y = cor, col = mat))+
  geom_line(aes(linetype = lty))+
  theme_bw()+
  # scale_x_discrete(breaks = 1:5, labels = c("50", "100", "200", "400", "1000"))+
  facet_grid(dgp~comb)+
  # ggokabeito::scale_color_okabe_ito()+
  theme(strip.text.x = element_text(size = 6))+
  theme_compare()+
  labs(x = "Timepoints")


df_cor_grid_reg <- df_cor_full %>% 
  group_by(iter_bggm, iter_gvar) %>% 
  # this summarizes prior info etc., which is the same within a simulation condition
  # just a trick to keep it in the df
  filter(dgp >2) %>% 
  dplyr::summarize(across(everything(),
                   ~mean(.))) %>% 
  pivot_longer(cols = c(contains("cor"), contains("diff")), values_to = "cor", names_to = "mat") %>%
  filter(!is.na(lambda)) %>% 
  mutate(comb = paste0("R: ", rho_prior, ", B: ", beta_prior,
                       ", G: ", gamma_ebic)) %>% 
  # add linetype
  mutate(lty = ifelse(grepl("sel", mat), "select", "nonselect")) %>% 
  ungroup() %>% 
  ggplot(aes(x = n_tp, y = cor, col = mat))+
  geom_line(aes(linetype = lty))+
  theme_bw()+
  facet_grid(dgp~comb)+
  # ggokabeito::scale_color_okabe_ito
  theme_compare()+
  theme(strip.text.x = element_text(size = 6))


# Use NULL to create some space between plots
plot_cor_grid_sep <- cowplot::plot_grid(
  NULL, df_cor_grid_nonreg, NULL, df_cor_grid_reg,
  labels = c("", "Regularized","", "Non-Regularized"), ncol = 1,
  align = "v",
  rel_heights= c(0.05, 1, 0.05, 1),
  label_x = .01, label_y = 1.05
)

ggsave("plot_cor_grid_sep.svg", plot_cor_grid_sep, height = 15, width = 18, path = here::here("figures/"), device = "svg")


```


## Compare performance BGGM and graphicalVAR
Only use one prior combination for BGGM.
```{r}
# add row iteration number
cond_grid <- cond_grid %>% 
  mutate(iter_bggm = dplyr::row_number())
cond_grid_gvar <- cond_grid_gvar %>% 
  mutate(iter_gvar = dplyr::row_number())



# add dataset iteration information to each
df_eval_bggm_ind <- df_eval_bggm %>% 
  group_by(dgp_ind, tp_ind, rho_prior, beta_prior) %>% 
  mutate(data_ind = dplyr::row_number())

df_eval_gvar_ind <- df_eval_gvar %>% 
  group_by(dgp_ind, tp_ind, lambda, ebic) %>% 
  mutate(data_ind = dplyr::row_number())


  
# For joining, select one of the prior conditions
df_eval_both <- df_eval_bggm_ind %>% 
  # filter(beta_prior == 0.5 & rho_prior == 0.5) %>% 
  left_join(df_eval_gvar_ind, by = c("dgp_ind", "tp_ind", "data_ind"),
            suffix = c("_bggm", "_gvar")) %>% 
  ungroup()
  
# TODO maybe add correlation to this as well?
# need to add "data_ind" to the df_cors



```

### Plot comparison of both methods

```{r}
plot_eval_both <- df_eval_both %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # dplyr::select(c(dgp_ind, tp_ind, lambda, ebic, contains("prior"), contains("bias"),contains("rmse"))) %>%
  dplyr::select(c(dgp_ind, tp_ind, lambda, ebic, contains("prior"), contains("bias"),contains("cor_beta"),
                  contains("cor_pcor"))) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  dplyr::group_by(dgp_ind, tp_ind, lambda, ebic, prior_comb) %>% 
  dplyr::summarize(across(c(contains("bias"),contains("cor_beta"), contains("cor_pcor")),
                   ~mean(., na.rm = TRUE))) %>% 
  pivot_wider(names_from = prior_comb, 
              values_from = c(contains("bggm"), contains("sel"))) %>% 
  pivot_longer(cols = c(contains("bias"), contains("cor_beta"), contains("cor_pcor")),
                        names_to = "stat") %>%
  mutate(method = case_when(
    stringr::str_detect(stat, "bggm_b0.2") ~ "BGGM narrow",
    stringr::str_detect(stat, "bggm_b1") ~ "BGGM wide",
    stringr::str_detect(stat, "gvar") ~ "gVAR",
    stringr::str_detect(stat, "sel_b0.2") ~ "SEL narrow",
    stringr::str_detect(stat, "sel_b1") ~ "SEL wide"
  )) %>% 
  mutate(mat = case_when(
    stringr::str_detect(stat, "beta") ~ "Temp.",
    stringr::str_detect(stat, "pcor") ~ "Contemp."
  )) %>% 
  mutate(stat = case_when(
    stringr::str_detect(stat, "bias") ~ "Bias",
    stringr::str_detect(stat, "rmse") ~ "RMSE",
    stringr::str_detect(stat, "cor_beta") ~ "Correlation",
    stringr::str_detect(stat, "cor_pcor") ~ "Correlation"
  )) %>% 
  # remove everything after first underscore
  # remove matrix from stat column
  mutate(stat = stringr::str_remove(stat, "_.*")) %>% 
  # add linetype
  mutate(lty = ifelse(grepl("SEL", method), "select", "nonselect")) %>% 
  # only take default values for now
  filter(is.na(lambda) & ebic == 0) %>% 
  ggplot(aes(x = tp_ind, y = value, col = method, group = method))+
  geom_line(aes(linetype = lty))+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat))+
  theme_bw()+
  ggokabeito::scale_color_okabe_ito()+
  labs(caption = "GVAR default",
       x = "Timepoints",
       col = "Method",
       y = "")+
  theme_compare()
plot_eval_both

ggsave("plot_eval_both_cor.svg", plot_eval_both, height = 7, width = 15, path = here::here("figures/"), device = "svg")

```


### Focus on selection methods
Here, focus on selection methods and investigate specificity, sensitivity etc. 
```{r}
plot_eval_both_select <- df_eval_both %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # dplyr::select(c(dgp_ind, tp_ind, lambda, ebic, contains("prior"), contains("bias"),contains("rmse"))) %>%
  dplyr::select(c(dgp_ind, tp_ind, lambda, ebic, contains("prior"), contains("spec"),contains("sens"),
                  contains("zeros"))) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  dplyr::group_by(dgp_ind, tp_ind, lambda, ebic, prior_comb) %>% 
  dplyr::summarize(across(c(contains("spec"),contains("sens"), contains("zeros")),
                   ~mean(., na.rm = TRUE))) %>% 
  pivot_wider(names_from = prior_comb, 
              values_from = c(contains("bggm"), contains("sel"))) %>% 
  pivot_longer(cols = c(contains("zeros"), contains("spec"), contains("sens")),
                        names_to = "stat") %>%

  mutate(method = case_when(
    stat == "zeros_beta" ~ "gVAR",
    stat == "zeros_pcor" ~ "gVAR",
    stringr::str_detect(stat, "gvar") ~ "gVAR",
    stringr::str_detect(stat, "sel_b0.2") ~ "SEL narrow",
    stringr::str_detect(stat, "bggm_b0.2") ~ "SEL narrow",
    stringr::str_detect(stat, "sel_b1") ~ "SEL wide",
    stringr::str_detect(stat, "bggm_b1") ~ "SEL wide"
  )) %>% 
  mutate(mat = case_when(
    stringr::str_detect(stat, "beta") ~ "Temp.",
    stringr::str_detect(stat, "pcor") ~ "Contemp."
  )) %>% 
  mutate(stat = case_when(
    stringr::str_detect(stat, "bias") ~ "Bias",
    stringr::str_detect(stat, "rmse") ~ "RMSE",
    stringr::str_detect(stat, "sens") ~ "Sensitivity",
    stringr::str_detect(stat, "spec") ~ "Specificity",
    stringr::str_detect(stat, "zeros") ~ "Zeros"
  )) %>% 
  # remove everything after first underscore
  # remove matrix from stat column
  mutate(stat = stringr::str_remove(stat, "_.*")) %>% 
  # add linetype
  # mutate(lty = ifelse(grepl("SEL", method), "select", "nonselect")) %>% 
  # filter out non-thresholded methods
  filter(!grepl("BGGM", method)) %>% 
  # only take default values for gvar now
  filter(is.na(lambda) & ebic == 0) %>% 
  filter(stat != "Zeros") %>% 
  ggplot(aes(x = tp_ind, y = value, col = method, group = method))+
  geom_line()+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat),
                      scales = "free")+
  theme_bw()+
  ggokabeito::scale_color_okabe_ito()+
  labs(caption = "GVAR default. 95%-CI for BGGM methods.",
       x = "Timepoints",
       col = "Method",
       y = "")+
  theme_compare()
plot_eval_both_select
```



### Coverage and interval width BGGM
Create a plot to investigate credible intervals of BGGM
```{r}
plot_eval_credible <- df_eval_both %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # only take default values for gvar now to filter out redundant information
  filter(is.na(lambda) & ebic == 0) %>% 
  dplyr::select(-c(lambda,ebic)) %>% 
  dplyr::select(c(dgp_ind, tp_ind, contains("prior"), contains("width"),contains("cover"))) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  dplyr::group_by(dgp_ind, tp_ind, prior_comb) %>% 
  # convert coverage into proportion
  mutate(n_nodes = ifelse(dgp_ind == "Simulated\nChain 8N", 8, 6)) %>% 
  mutate(across(contains("sum_cover_beta"),
                ~ ./n_nodes^2)) %>% 
  # divide by number of unique off-diagonal elements
  mutate(across(contains("sum_cover_pcor"),
                ~ ./((n_nodes/2)*(n_nodes-1)))) %>% 
  dplyr::summarize(across(c(contains("width"), contains("cover")),
                   ~mean(., na.rm = TRUE))) %>% 
  pivot_longer(cols = c(contains("width"), contains("cover")),
                        names_to = "stat") %>%
  mutate(mat = case_when(
    stringr::str_detect(stat, "beta") ~ "Temp.",
    stringr::str_detect(stat, "pcor") ~ "Contemp."
  )) %>% 
  # add line for coverage
  mutate(intercept = case_when(
    stringr::str_detect(stat, "cover_beta_0.9$") ~ 0.9,
    stringr::str_detect(stat, "cover_beta_0.95") ~ 0.95,
    stringr::str_detect(stat, "cover_beta_0.99") ~ 0.99,
    stringr::str_detect(stat, "cover_pcor_0.9$") ~ 0.9,
    stringr::str_detect(stat, "cover_pcor_0.95") ~ 0.95,
    stringr::str_detect(stat, "cover_pcor_0.99") ~ 0.99,
    .default = 0
  )) %>% 
  # Little trick to not show horizontal line for the width facets
  mutate(line_alpha = case_when(
    stringr::str_detect(stat, "cover") ~ 1,
    stringr::str_detect(stat, "width") ~ 0
  )) %>% 
    mutate(stat = case_when(
    stringr::str_detect(stat, "width_beta_0.9$") ~ "Width 0.9",
    stringr::str_detect(stat, "width_beta_0.95") ~ "Width 0.95",
    stringr::str_detect(stat, "width_beta_0.99") ~ "Width 0.99",
    stringr::str_detect(stat, "width_pcor_0.9$") ~ "Width 0.9",
    stringr::str_detect(stat, "width_pcor_0.95") ~ "Width 0.95",
    stringr::str_detect(stat, "width_pcor_0.99") ~ "Width 0.99",
    stringr::str_detect(stat, "cover_beta_0.9$") ~ "Coverage 0.9",
    stringr::str_detect(stat, "cover_beta_0.95") ~ "Coverage 0.95",
    stringr::str_detect(stat, "cover_beta_0.99") ~ "Coverage 0.99",
    stringr::str_detect(stat, "cover_pcor_0.9$") ~ "Coverage 0.9",
    stringr::str_detect(stat, "cover_pcor_0.95") ~ "Coverage 0.95",
    stringr::str_detect(stat, "cover_pcor_0.99") ~ "Coverage 0.99",
  )) %>% 

  ggplot(aes(x = tp_ind, y = value, col = prior_comb, group = prior_comb))+
  geom_hline(aes(yintercept = intercept, alpha = line_alpha), 
             col = "#D5D8DC")+
  geom_line()+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat))+
  theme_bw()+
  ggokabeito::scale_color_okabe_ito()+
  labs(x = "Timepoints",
       col = "Priors",
       y = "")+
  theme_compare()

plot_eval_credible 
ggsave("plot_eval_credible.svg", plot_eval_credible, height = 7, width = 12, path = here::here("figures/"), device = "svg")

```



## Average model across simulation fits
Find averaged model across 1000 iterations in one condition. 
```{r}
# BGGM
pcor_list <- lapply(fit_bggm[[30]], function(x)
  return(x$pcor_mu))

pcor_bggm <- apply(simplify2array(pcor_list), 1:2, mean)
diag(pcor_bggm) <- rep(0, 6)
options(scipen = 10)
pcor_bggm

beta_list <- lapply(fit_bggm[[70]], function(x)
  return(x$beta_mu))

apply(simplify2array(beta_list), 1:2, mean)


# gVAR

PCC_gvar_list <- lapply(l_res_gvar[[30]], function(x)
  return(x$PCC))

round(apply(simplify2array(PCC_gvar_list), 1:2, mean),3)

beta_gvar_list <- lapply(l_res_gvar[[30]], function(x)
  return(t(x$beta[,-1])))

round(apply(simplify2array(beta_gvar_list), 1:2, mean),3)


```








