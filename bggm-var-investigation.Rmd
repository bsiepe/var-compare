---
title: "bggm-var-investigation"
author: "Bj√∂rn Siepe"
date: "2022-11-18"
output: html_document
---
In this file, I investigate some of the properties of BGGM var_estimate. 
Does it actually work well? If so, the following should be true.
1. It should perform regularization as it says.
2. It should recover roughly the same estimate as, e.g., graphicalVAR. 


```{r}
source("aux_funs.R")
```



# Test regularization
```{r}
# library("BGGM", lib.loc = "C:/Users/Bjoern/R-dev")


set.seed(2022)
compgraph <- graphicalVAR::randomGVARmodel(Nvar = 6, probKappaEdge = 0.4, probBetaEdge = .2)
dat <- as.data.frame(graphicalVAR::graphicalVARsim(200, beta = compgraph$beta, kappa = compgraph$kappa))
res <- var_estimate(dat,
                          beta_sd = 1)
res2 <- BGGM::var_estimate(dat,
                           beta_sd = 0.1)


# Try the same for rho
res3 <- BGGM::var_estimate(dat,
                          rho_sd = 0.5)
res4 <- BGGM::var_estimate(dat,
                          rho_sd = 0.05)



```

# Compare with GraphicalVAR

For now, just simulate 100 datasets from the same DGP. 
```{r generate-data}
# Storage
l_gvardata <- list()

# Simulation conditions
n_ind <- 200   # number of individuals (so models to create)
n_tp <- 150     # number of timepoints per time series

ncores = parallel::detectCores() - 4
cl = makeCluster(ncores)
registerDoParallel(cl)

l_gvardata <- sim_raw_parallel(dgp = compgraph, n = n_ind, 
                                tp = n_tp, means = 0,
                                standardize = TRUE)

stopCluster(cl)





```

```{r fit-models}
# Model specifics
rho_sd <- 0.5
beta_sd <- 1
seed <- 2022
n_iter <- 5000

l_compres <- list()
ncores = parallel::detectCores() - 4
cl = makeCluster(ncores)
registerDoParallel(cl)

l_compres$bggm <- fit_var_parallel(data = l_gvardata, n = n_ind,
                 rho_prior = rho_sd, beta_prior = beta_sd, seed = seed,
                 iterations = n_iter)

l_compres$gvar <- foreach(i = seq(n_ind), .packages = "graphicalVAR") %dopar% {
  tmp_res <- graphicalVAR(data = l_gvardata[[i]]$data, 
               lambda_beta = 0,
               lambda_kappa = 0, 
               scale = TRUE, 
               gamma = 0)
  
  tmp_res
  
}

stopCluster(cl)


```



Now we can compare the results. What do we look at? Due to no regularization, do not look at true positives/false positives here. 
- difference from data-generating process


TODO: Is it fine not to look at the intercepts? This might be important. 
TODO: Do I need the transpose?
TODO: Add correlations


```{r compare-results}
comp_res <- compare_dgp(true = compgraph, 
                        est_bggm = l_compres$bggm, 
                        est_gvar = l_compres$gvar, n = 200)


```

Plot results: (this should be added as a function later on)
```{r plot-results}



```


Works pretty well for n = 200 and one graph. Default priors seem to be okay, only has convergence issues in some cases.  





# Simulation study

## Data Generation
Just use "truegraph" data from main simulation study for now. 
```{r}
l_raw <- readRDS("l_raw.RDS")

# Only truegraph
l_dgp <- list()
l_dgp$graph1 <- lapply(l_raw$graph1, function(x){
  y <- x$truegraph
  y
})
l_dgp$graph2 <- lapply(l_raw$graph2, function(x){
  y <- x$truegraph
  y
})
l_dgp$graph3 <- lapply(l_raw$graph3, function(x){
  y <- x$truegraph
  y
})




```



## Estimation
Estimate both graphicalVAR in default settings as well as BGGM with varying priors.
```{r}
# Priors
dgp <- c(1,2,3)
rho_prior <- c(0.1, 0.3, 0.5)
beta_prior <- c(0.2, 0.5, 1)
n_tp <- c(50, 100, 200, 400) # TODO add timepoint condition?
tp_cond <- c(1,2,3,4)   # different tp conditions

cond_grid <- expand.grid(dgp = dgp,
                         n_tp = tp_cond,
                         rho_prior = rho_prior, 
                         beta_prior = beta_prior)
iterations <- 15000
seed <- 2022



# Estimating for each model 
# store BGGM results under "nonselect"
ncores = parallel::detectCores() - 2
cl = makeCluster(ncores)
registerDoParallel(cl)
l_res <- list()

# TODO replace with 1:nrow(comp_grid)
for(n in 1:3) {
  dgp <- as.numeric(cond_grid[n, "dgp"])
  n_tp <- as.numeric(cond_grid[n, "n_tp"])
  rho_prior <- as.numeric(cond_grid[n, "rho_prior"])
  beta_prior <- as.numeric(cond_grid[n, "beta_prior"])
  
  l_res[[n]]  <- lapply(l_dgp[[dgp]][[n_tp]], function(x){ 
                          fit_var_parallel_merged(
                          data = x,
                          rho_prior = rho_prior,
                          beta_prior = beta_prior,
                          iterations = iterations,
                          n = 100,
                          nds = 100,
                          seed = seed,
                          pruneresults = TRUE,
                          save_files = FALSE)
    })
                          
  
}
stopCluster(cl)



```




## Evaluation
Evaluate both with and without graph selection.

### Selection
```{r}
# Loop over all graphs, extract BGGM fitting object and apply the selection function 
# extend select function to also include the lower and upper bound 





```




```{r}


```












