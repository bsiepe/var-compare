---
title: "bggm-var-investigation"
author: "Bj√∂rn Siepe"
date: "2022-11-18"
output: html_document
---

```{r}
library(tidyverse)
library(doParallel)
library(parallel)
library(foreach)
library(BGGM)
library(graphicalVAR)
library(cowplot)
library(sysfonts)
source("aux_funs.R")

seed = 2022
set.seed(seed)
```

# Simulation study

Simulation conditions

```{r}
# Simulation conditions
n_ind <- 1000 # number of individuals(so models to create) 
n_tp <- c(50,100,200,400,1000) # number of timepoints
n_postds <- 1000 # number of datasets per condition
seed <- 2022
dgp_names <- c("graph1", "graph2", "graph3", "graph4", "graph5", "graph6")

# Priors
dgp <- c(1,2,3,4,5,6)
rho_sd <- c(0.1, 0.3, 0.5)
beta_sd <- c(0.2, 0.5, 1)
n_tp <- c(50, 100, 200, 400, 1000) 
tp_cond <- c(1,2,3,4,5)   # different tp conditions
n_iter <- 50000

cond_grid <- expand.grid(dgp = dgp,
                         n_tp = tp_cond,
                         rho_prior = rho_sd, 
                         beta_prior = beta_sd)
# Conditions of varying sparsity for graphicalVAR
gamma_ebic <- c(0, 0.5)      # EBIC hyperparameter
lambda <- c(NA, 0)


cond_grid_gvar <- expand.grid(dgp = dgp,
                         n_tp = tp_cond,
                         gamma_ebic = gamma_ebic,
                         lambda = lambda)

```

## Data Generation

```{r}
# l_raw <- readRDS(l_raw, file = here::here("data/l_raw1000.RDS"))

set.seed(seed)
before_simraw <- Sys.time()
ncores = 40
cl = makeCluster(ncores)
registerDoParallel(cl)
l_raw <- list()
l_raw$graph6 <- l_raw$graph5 <- l_raw$graph4 <- l_raw$graph3 <- l_raw$graph2 <- l_raw$graph1 <-  list()
for(dgp in dgp_names){
  for(t in seq_along(n_tp)){
  l_raw[[dgp]][[t]] <- list()
  l_raw[[dgp]][[t]] <- sim_raw_parallel(dgp = l_graphs[[dgp]],
                                    n = n_postds,
                                    tp = n_tp[t],
                                    seed = seed,
                                    means = 0,
                                    standardize = TRUE)

}
}


stopCluster(cl)


# saveRDS(l_raw, file = here::here("data/l_raw1000.RDS"))



```

## Estimation

Estimate both graphicalVAR in default settings as well as BGGM with varying priors.

Next steps here: load results, then figure out which files haven't been done yet

```{r}
# Estimating for each model 
# store BGGM results under "nonselect"
ncores = 50
cl = makeCluster(ncores)
clusterExport(cl = cl, "summarize_post")
registerDoParallel(cl)
l_res_bggm <- list()



for(n in 1:nrow(cond_grid)) {
  dgp_ind <- as.numeric(cond_grid[n, "dgp"])
  tp_ind <- as.numeric(cond_grid[n, "n_tp"])
  r_sd <- as.numeric(cond_grid[n, "rho_prior"])
  b_sd <- as.numeric(cond_grid[n, "beta_prior"])
  print(paste0(nrow(cond_grid)-n, " to go!"))
  l_res_bggm[[n]]  <- fit_var_parallel_merged(l_raw[[dgp_ind]][[tp_ind]],
                          rho_prior = r_sd,
                          beta_prior = b_sd,
                          iterations = n_iter,
                          n = 1000,
                          nds = 1000,
                          seed = seed,
                          get_kappa = FALSE, 
                          summarize_post = TRUE,
                          cred_int = c(0.9, 0.95, 0.99),
                          pruneresults = FALSE,
                          save_files = FALSE,
                          multigroup = FALSE,
                          select = TRUE)
    

  
}
stopCluster(cl)

# Attach the simulation conditions
for(m in 1:nrow(cond_grid)){
  for(i in 1:length(l_res_bggm[[m]])){
    l_res_bggm[[m]][[i]]$sim_cond <- cond_grid[m,]
  }
}

saveRDS(l_res_bggm, here::here("output/bggm-var-sim-res_2403.Rds"))
# l_res_bggm <- readRDS(here::here("output/bggm-var-sim-res_2403.Rds"))



```

### Fit graphicalVAR

```{r}
ncores = 50
cl = makeCluster(ncores)
clusterExport(cl = cl, "fit_graphicalvar_parallel")
registerDoParallel(cl)
l_res_gvar <- list()
time_before_gvar <- Sys.time()
for(n in 1:nrow(cond_grid_gvar)) {
  dgp_ind <- as.numeric(cond_grid_gvar[n, "dgp"])
  tp_ind <- as.numeric(cond_grid_gvar[n, "n_tp"])
  gamma_ebic <- as.numeric(cond_grid_gvar[n, "gamma_ebic"])
  lambda <- as.numeric(cond_grid_gvar[n, "lambda"])
  print(paste0(nrow(cond_grid_gvar)-n, " to go!"))
  
  # unregularized
  if(!is.na(lambda)){
   l_res_gvar[[n]]  <- fit_graphicalvar_parallel(l_raw[[dgp_ind]][[tp_ind]],
                                                  n = 1000,
                                                  gamma = gamma_ebic,
                                                  nLambda = 50, 
                                                  pruneresults = TRUE, 
                                                  lambda_beta = lambda,
                                                  lambda_kappa = lambda)
                            
  }
  # regularized
  if(is.na(lambda)){
   l_res_gvar[[n]]  <- fit_graphicalvar_parallel(l_raw[[dgp_ind]][[tp_ind]],
                                                 n = 1000,
                                                 gamma = gamma_ebic,
                                                 nLambda = 50, 
                                                 pruneresults = TRUE)
    
  }
    

  
}
stopCluster(cl)

time_after_gvar <- Sys.time() - time_before_gvar


# Attach the simulation conditions
for(m in 1:nrow(cond_grid_gvar)){
  for(i in 1:length(l_res_gvar[[m]])){
    l_res_gvar[[m]][[i]]$sim_cond <- cond_grid_gvar[m,]
  }
}

# saveRDS(l_res_gvar, here::here("output/graphicalvar-sim-res_2403.Rds"))
# l_res_gvar <- readRDS(here::here("output/graphicalvar-sim-res_1703.Rds"))

    



```

## Evaluation

Evaluate both with and without graph selection.
```{r}
l_res_bggm <- readRDS(here::here("output/bggm-var-sim-res_2403.Rds"))
l_res_gvar <- readRDS(here::here("output/graphicalvar-sim-res_2403.Rds"))
l_graphs <- readRDS(here::here("data/l_graphs.RDS"))


## BGGM
l_eval_bggm <- lapply(l_res_bggm, function(x){
  res <- lapply(x, eval_bggm)
  return(res)
})

rm(l_res_bggm)
df_eval_bggm <- purrr::flatten(l_eval_bggm)
df_eval_bggm <- dplyr::bind_rows(df_eval_bggm)
# Pivot CIs wider
df_eval_bggm_wide <- df_eval_bggm %>% 
  tidyr::unpack(cols = ci) %>% 
  pivot_wider(names_from = ci, values_from = c(sum_cover_beta, sum_cover_pcor,
                                               width_beta, width_pcor))
rm(df_eval_bggm)
rm(l_eval_bggm)
df_eval_bggm <- df_eval_bggm_wide
rm(df_eval_bggm_wide)


## GVAR
l_eval_gvar <- list()
for(i in 1:nrow(cond_grid_gvar)){
  l_eval_gvar[[i]] <- lapply(l_res_gvar[[i]], eval_gvar)
}

# Convert to dataframe
df_eval_gvar <- purrr::flatten(l_eval_gvar)
df_eval_gvar <- dplyr::bind_rows(df_eval_gvar)
rm(l_eval_gvar)

# save evaluations
# saveRDS(df_eval_gvar, here::here("output/df_eval_gvar_0705.RDS"))
# saveRDS(df_eval_bggm, here::here("output/df_eval_bggm_0705.RDS"))
df_eval_gvar <- readRDS(here::here("output/df_eval_gvar_0705.RDS"))
df_eval_bggm <- readRDS(here::here("output/df_eval_bggm_0705.RDS"))

```


New evaluation with standard errors. 
```{r}
n_rep = 1000

## For GVAR
df_eval_gvar_mcse <- df_eval_gvar %>% 
   # pivot_longer, split beta and pcor
    pivot_longer(cols = -c(dgp_ind, tp_ind, lambda, ebic), 
               names_to = c(".value", "mat"), 
               names_pattern = "(.*)_([^_]+)$") %>% 
  dplyr::group_by(dgp_ind, tp_ind, lambda, ebic, mat) %>% 
  dplyr::summarize(
    bias = mean(bias), 
    bias_mcse = sqrt((1/(n_rep*(n_rep-1)))*sum(bias_sq)),  # double check the square here
    cor = mean(cor), 
    cor_mcse = sqrt(1-cor^2)/sqrt(n_rep-2),
    sens = mean(sens), 
    sens_mcse = sqrt((sens * (1-sens))/n_rep),
    spec = mean(spec),
    spec_mcse = sqrt((spec * (1-spec))/n_rep)) %>% 
  ungroup()


## For BGGM
df_eval_bggm_mcse <- df_eval_bggm %>% 
  # pivot_longer, split beta and pcor
  tidyr::pivot_longer(cols = -c(dgp_ind, tp_ind, rho_prior, beta_prior,
                           contains("cover"), contains("width")), 
               names_to = c(".value", "mat"), 
               names_pattern = "(.*)_([^_]+)$") %>% 
  # seperate SEL and non-select
  # tidyr::pivot_longer(cols = c(contains("bias"), cor, cor_sel, contains("rmse"))) %>% 
  # mutate(method = ifelse(grepl("_sel", name), "sel", "bggm")) %>% 
  # mutate(name = stringr::str_remove(name, "_sel")) %>% 
  rename(bias_bggm = bias, 
         rmse_bggm = rmse, 
         cor_bggm = cor) %>% 
    pivot_longer(
    cols = c(bias_bggm, rmse_bggm, cor_bggm, bias_sel, rmse_sel, cor_sel),  # Specify the columns to pivot
    names_to = c(".value", "method"),  # Specify the new column names
    names_pattern = "(.*)_(.*)"  # Pattern to match the column names
  ) %>% 
  dplyr::group_by(dgp_ind, tp_ind, rho_prior, beta_prior, mat, method) %>% 
  dplyr::summarize(
    bias = mean(bias), 
    bias_mcse = sqrt((1/(n_rep*(n_rep-1)))*sum(bias_sq)),  # double check the square here
    cor = mean(cor), 
    cor_mcse = sqrt(1-cor^2)/sqrt(n_rep-2),
    sens = mean(sens), 
    sens_mcse = sqrt((sens * (1-sens))/n_rep),
    spec = mean(spec),
    spec_mcse = sqrt((spec * (1-spec))/n_rep)) %>% 
  ungroup()



```





Combine evaluations.
```{r}
# No longer relevant for new evaluation
# # add row iteration number
# cond_grid <- cond_grid %>% 
#   mutate(iter_bggm = dplyr::row_number())
# cond_grid_gvar <- cond_grid_gvar %>% 
#   mutate(iter_gvar = dplyr::row_number())
# 
# 
# # add dataset iteration information to each
# df_eval_bggm_ind <- df_eval_bggm %>% 
#   group_by(dgp_ind, tp_ind, rho_prior, beta_prior) %>% 
#   mutate(data_ind = dplyr::row_number())
# 
# df_eval_gvar_ind <- df_eval_gvar %>% 
#   group_by(dgp_ind, tp_ind, lambda, ebic) %>% 
#   mutate(data_ind = dplyr::row_number())


  
# For joining, select one of the prior conditions
df_eval_both <- df_eval_bggm_mcse %>% 
  # filter(beta_prior == 0.5 & rho_prior == 0.5) %>% 
  left_join(df_eval_gvar_mcse, by = c("dgp_ind", "tp_ind", "mat"),
            suffix = c("_bggm", "_gvar")) %>% 
  ungroup() %>% 
  # selection vs. nonselection pivot wider
  pivot_wider(
    names_from = method, 
    values_from = c(contains("bggm")),
    names_sep = "_"
  ) %>% 
    rename_with(~ gsub("_bggm_", "_", .), contains("_bggm_"))
  
  



```

### Plotting results

Prepare plotting. 

```{r}
# Timepoint values with all levels
tp_levels <- c("50" = "1", "100" = "2", "200" = "3", "400" = "4", "1000" = "5")

# DGP cut: should old dgps be cut? then set this to 2
# if not, set to 0
dgp_cut <- 2

# DGP Names
dgp_levels <- c("Old1" = "1", "Old2" = "2", "Empirical\nSparse" = "3",
                 "Simulated\nChain 6N" = "4", "Simulated\nNonsparse" = "5",
                 "Simulated\nChain 8N" = "6")

# With deleting old DGPs
dgp_levels <- c("Empirical\nSparse" = "3",
                 "Simulated\nChain 6N" = "4", "Simulated\nNonsparse" = "5",
                 "Simulated\nChain 8N" = "6")

# Colors consistent across plots
cond_colors <- set_names(ggokabeito::palette_okabe_ito()[1:5],
                         c("BGGM narrow", "BGGM wide", "graphicalVAR", "SEL wide", "SEL narrow"))


```


## NEW PLOTS WITH UNCERTAINTY
Prepare data: Pivot longer and mutate columns. 
```{r}
# Pivot longer and mutate columns
df_eval_both_long <- df_eval_both %>% 
  ungroup() %>% 
  # Filter irrelevant condition
  dplyr::filter(!(!is.na(lambda) & ebic == 0.5)) %>% 
  tidyr::pivot_longer(cols = c(contains("bias"), contains("cor"), contains("mcse"), contains("spec"), contains("sens"))) %>%
  mutate(val_type = case_when(
    stringr::str_detect(name, "mcse") ~ "mcse",
    TRUE ~ "value"
  )) %>%   
  mutate(method = case_when(
    stringr::str_detect(name, "bggm") ~ "BGGM",
    stringr::str_detect(name, "sel") ~ "SEL",
    stringr::str_detect(name, "gvar") ~ "graphicalVAR"
  )) %>% 
  mutate(name = stringr::str_remove(name, "_.*")) %>% 
  rename(stat = name) %>% 
  pivot_wider(names_from = val_type, 
              values_from = value) %>% 
  mutate(mat = case_when(
    stringr::str_detect(mat, "beta") ~ "Temporal",
    stringr::str_detect(mat, "pcor") ~ "Contemporaneous"
  )) %>% 
 mutate(stat = case_when(
                          stringr::str_detect(stat, "sens") ~ "Sensitivity",
                          stringr::str_detect(stat, "spec") ~ "Specificity",
                          stringr::str_detect(stat, "bias") ~ "Bias",
                          stringr::str_detect(stat, "cor") ~ "Correlation"))
  
  

```




### Plot BGGM
This is not done yet; I need to think about what to include.
```{r}
df_eval_bggm %>% 
  filter(dgp_ind > dgp_cut) %>% 
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  

```



### Plot both
```{r}
plot_eval_both <- df_eval_both_long %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  dplyr::group_by(dgp_ind, tp_ind, lambda, ebic, prior_comb) %>% 
  mutate(method = paste0(method, "_", prior_comb)) %>% 
  mutate(method = case_when(
    stringr::str_detect(method, "BGGM_b0.2") ~ "BGGM narrow",
    stringr::str_detect(method, "BGGM_b1") ~ "BGGM wide",
    stringr::str_detect(method, "graphicalVAR") ~ "graphicalVAR",
    stringr::str_detect(method, "SEL_b0.2") ~ "SEL narrow",
    stringr::str_detect(method, "SEL_b1") ~ "SEL wide"
  )) %>% 
  # add linetype
  mutate(lty = ifelse(grepl("SEL", method), "select", "nonselect")) %>% 
  # only take default values for now
  filter(is.na(lambda) & ebic == 0) %>% 
  # not look at spec/sens here
  filter(!stat %in% c("Sensitivity", "Specificity")) %>% 
  ggplot(aes(x = tp_ind, y = value, col = method, group = method))+
  geom_line(aes(linetype = lty))+
  geom_linerange(aes(ymin = value - 1.96*mcse,
                            ymax = value + 1.96*mcse),
                        width = .5, 
                 # position = position_dodge(0.1)
                 )+
  # geom_point()+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat))+
  theme_bw()+
  scale_color_manual(values = cond_colors)+
  labs(x = "Timepoints",
       col = "Method",
       y = "",
       linetype = "Select")+
  theme_compare()+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

plot_eval_both
ggsave("plot_eval_both_cor.svg", plot_eval_both, height = 9, width = 12, path = here::here("figures/"), device = "svg")


```


### Plot Selection Methods
```{r}
plot_eval_select <- df_eval_both_long %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  dplyr::group_by(dgp_ind, tp_ind, lambda, ebic, prior_comb) %>% 
  mutate(method = paste0(method, "_", prior_comb)) %>% 
  mutate(method = case_when(
    stringr::str_detect(method, "BGGM_b0.2") ~ "BGGM narrow",
    stringr::str_detect(method, "BGGM_b1") ~ "BGGM wide",
    stringr::str_detect(method, "graphicalVAR") ~ "graphicalVAR",
    stringr::str_detect(method, "SEL_b0.2") ~ "SEL narrow",
    stringr::str_detect(method, "SEL_b1") ~ "SEL wide"
  )) %>% 
  # disregard non-select methods
  filter(!grepl("BGGM", method)) %>% 
  # add linetype
  mutate(lty = ifelse(grepl("SEL", method), "select", "nonselect")) %>% 
  # only take default values for now
  filter(is.na(lambda) & ebic == 0) %>% 
  # not look at spec/sens here
  filter(stat %in% c("Sensitivity", "Specificity")) %>% 
  ggplot(aes(x = tp_ind, y = value, col = method, group = method))+
  geom_line(aes(linetype = lty))+
  geom_linerange(aes(ymin = value - 1.96*mcse,
                            ymax = value + 1.96*mcse),
                        width = .5, 
                 # position = position_dodge(0.1)
                 )+
  # geom_point()+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat))+
  theme_bw()+
  scale_color_manual(values = cond_colors)+
  labs(x = "Timepoints",
       col = "Method",
       y = "",
       linetype = "Select")+
  theme_compare()+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

plot_eval_select
ggsave("plot_eval_select.svg", plot_eval_select, height = 9, width = 12, path = here::here("figures/"), device = "svg")


```










## OLDER WITHOUT STANDARD ERRORS
#### Plot BGGM

```{r}
df_eval_bggm_summary <- df_eval_bggm %>% 
  filter(dgp > dgp_cut) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  group_by(dgp_ind, tp_ind, rho_prior, beta_prior) %>% 
  # convert coverage into proportion
  mutate(n_nodes = ifelse(dgp_ind == 6, 8, 6)) %>% 
  mutate(across(contains("sum_cover_beta"),
                ~ ./n_nodes^2)) %>% 
  # divide by number of unique off-diagonal elements
  mutate(across(contains("sum_cover_pcor"),
                ~ ./((n_nodes/2)*(n_nodes-1)))) %>% 
  summarize(across(c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                   bias_beta_sel, bias_pcor_sel, cor_beta_sel,                                    cor_pcor_sel, spec_beta, spec_pcor,
                   sens_beta, sens_pcor, contains("sum_cover")), 
                   .fns = list(mean = mean, 
                               sd = sd,
                               # se = ~ sd / sqrt(1000),
                               # lower = ~ mean - 1.96*se, 
                               # upper = ~ mean + 1.96*se, 
                               median = ~ median(.x, na.rm = TRUE))))

df_eval_bggm_long <- df_eval_bggm %>% 
  filter(dgp > dgp_cut) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  group_by(dgp_ind, tp_ind, rho_prior, beta_prior) %>% 
  # convert coverage into proportion
  mutate(n_nodes = ifelse(dgp_ind == 6, 8, 6)) %>% 
  mutate(across(contains("sum_cover_beta"),
                ~ ./n_nodes^2)) %>% 
  # divide by number of unique off-diagonal elements
  mutate(across(contains("sum_cover_pcor"),
                ~ ./((n_nodes/2)*(n_nodes-1)))) %>% 
  summarize(across(c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                   bias_beta_sel, bias_pcor_sel, cor_beta_sel, cor_pcor_sel, spec_beta, spec_pcor,
                   sens_beta, sens_pcor, contains("sum_cover")), 
                   ~mean(.))) %>% 
  pivot_longer(cols = c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                   bias_beta_sel, bias_pcor_sel, cor_beta_sel, cor_pcor_sel, spec_beta, spec_pcor,
                   sens_beta, sens_pcor, contains("sum_cover")), names_to = "stat", 
               values_to = "value") %>% 
  mutate(prior_comb = paste0(expression(rho)," = ", rho_prior,", ", expression(beta)," = ", beta_prior)) %>% 
  ungroup() 
  
  
plot_eval_bggm <- df_eval_bggm_long %>% 
  ggplot(aes(x = tp_ind, y = value, col = prior_comb, group = prior_comb)) + 
  facet_grid(dgp_ind ~ stat) + 
  geom_line() + 
  theme_bw()+
  theme_compare()+
  labs(x = "Timepoints",
       col = "Priors")+
  # guides(color = guide_legend(col = parse(text = prior_comb)))+
  ylim(0,1)+
  ggokabeito::scale_color_okabe_ito()

ggsave("plot_eval_bggm.svg", plot_eval_bggm, path = here::here("figures/"), device = "svg", width = 30, height = 9)  


# Eval plot with boxplots
# TODO: Use less conditions
plot_eval_bggm_box <- df_eval_bggm %>% 
  filter(dgp_ind > dgp_cut) %>% 
  group_by(dgp_ind, tp_ind, rho_prior, beta_prior) %>% 
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>%
  pivot_longer(cols = c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                   bias_beta_sel, bias_pcor_sel, cor_beta_sel, cor_pcor_sel, spec_beta, spec_pcor,
                   sens_beta, sens_pcor, contains("sum_cover")), names_to = "stat",
               values_to = "value") %>% 
  mutate(prior_comb = paste0("rho = ", rho_prior, ", beta = ", beta_prior)) %>% 
  ungroup() %>% 
  ggplot(aes(x = tp_ind, y = value, col = prior_comb)) + 
  ggh4x::facet_nested(dgp_ind ~ stat + mat) + 
  theme_compare()+
  geom_boxplot(outlier.size = 0.5, outlier.alpha = 0.4, outlier.color = "grey") + 
  ylim(0,1)+
  ggokabeito::scale_color_okabe_ito()
plot_eval_bggm_box
ggsave("plot_eval_bggm_boxplot.svg", plot_eval_bggm_box, path = here::here("figures/"), device = "svg", width = 16, height = 9)  

```

### Plot GVAR

Plot results

```{r}
plot_eval_gvar <- df_eval_gvar %>% 
  filter(dgp_ind > dgp_cut) %>% 
    mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
    # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  dplyr::mutate(lambda = as.character(lambda)) %>% 
  dplyr::mutate(lambda = tidyr::replace_na(lambda, "default")) %>% 
  dplyr::group_by(dgp_ind, tp_ind, ebic, lambda) %>% 
  dplyr::summarize(across(c(bias_beta, bias_pcor, cor_beta, cor_pcor,
                     spec_beta, spec_pcor,
                     sens_beta, sens_pcor),
                   ~mean(.))) %>% 
  tidyr::pivot_longer(cols = (c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                         spec_beta, spec_pcor,
                         sens_beta, sens_pcor)), 
               names_to = "stat", values_to = "value") %>% 
  dplyr::mutate(ebic_lambda_comb = paste0("Gamma: ", ebic, ", Lambda = ", lambda)) %>% 
  # filter redundant condition
  # EBIC is irrelevant when not regularizing, so this is 
  # identical to using Gamma: 0
  dplyr::filter(ebic_lambda_comb != "Gamma: 0.5, Lambda = 0") %>% 
  mutate(mat = case_when(
    stringr::str_detect(stat, "beta") ~ "Temp.",
    stringr::str_detect(stat, "pcor") ~ "Contemp."
  )) %>% 
  # remove everything after first underscore
  # remove matrix from stat column
  mutate(stat = stringr::str_remove(stat, "_.*")) %>% 
  mutate(stat = case_when(
                          stringr::str_detect(stat, "sens") ~ "Sensitivity",
                          stringr::str_detect(stat, "spec") ~ "Specificity",
                          stringr::str_detect(stat, "bias") ~ "Bias",
                          stringr::str_detect(stat, "cor") ~ "Correlation")) %>% 
  ungroup() %>% 
  ggplot(aes(x = tp_ind, y = value, col = ebic_lambda_comb, group = ebic_lambda_comb))+
  geom_line()+
  ggh4x::facet_nested(dgp_ind ~ stat + mat) + 
  ylim(0,1)+
  theme_compare()+
  ggokabeito::scale_colour_okabe_ito()+
  labs(col = "Model Setup", 
       x = "Timepoints",
       y = "")

plot_eval_gvar

ggsave("plot_eval_gvar.svg", plot_eval_gvar, path = here::here("figures/"), device = "svg", width = 16, height = 9)  

```

#### With uncertainty

## Correlate BGGM and graphicalVAR

BGGM and GVAR simulations have different amount of conditions, so I need to match them on their DGP + number of time points first

```{r}
cond_grid_full <- cond_grid %>% 
  mutate(iter_bggm = dplyr::row_number()) %>% 
  left_join(cond_grid_gvar %>% mutate(iter_gvar = dplyr::row_number()),
            by = c("dgp", "n_tp"))

# loop through all conditions and compute correlations
l_cor <- list()
for(i in 1:nrow(cond_grid_full)){
  iter_bggm <- cond_grid_full[i, "iter_bggm"]
  iter_gvar <- cond_grid_full[i, "iter_gvar"]
  
  l_cor[[i]] <- mapply(compare_bggm_gvar, l_res_bggm[[iter_bggm]], l_res_gvar[[iter_gvar]], SIMPLIFY = FALSE)
  
  # add iteration information
  l_cor[[i]] <- lapply(l_cor[[i]], function(x){
    x$iter_bggm <- iter_bggm
    x$iter_gvar <- iter_gvar
    return(x)
  })
}

l_cor_flat <- flatten(l_cor)
df_cor <- dplyr::bind_rows(l_cor_flat)

# NAs are zeroes 
df_cor_full <- df_cor %>% 
  mutate(across(contains("cor"),
                ~tidyr::replace_na(., replace = 0))) %>% 
  left_join(cond_grid_full, by = c("iter_bggm", "iter_gvar"))


```

Visualize results across simulation conditions. This does not work :(

```{r}
df_cor_grid  <- df_cor_full %>% 
  filter(dgp > dgp_cut)
  dplyr::group_by(iter_bggm, iter_gvar) %>% 
  # this summarizes prior info etc., which is the same within a simulation condition
  # just a trick to keep it in the df
  dplyr::summarize(across(everything(),
                   ~mean(.))) %>% 
  tidyr::pivot_longer(cols = contains("cor"), values_to = "cor", names_to = "mat") %>% 
  dplyr::mutate(comb = paste0("R: ", rho_prior, ", B: ", beta_prior,
                       ", G: ", gamma_ebic, ", L : ", lambda)) %>% 
  dplyr::ungroup() %>% 
  ggplot(aes(x = as.factor(n_tp), y = cor, col = mat))+
  geom_line()+
  theme_bw()+
  facet_grid(dgp~comb)+
  # ggokabeito::scale_color_okabe_ito()+
  theme(strip.text.x = element_text(size = 3))


ggsave("df_cor_grid.svg", df_cor_grid, height = 5, width = 25, path = here::here("figures/"),
       device = "svg")


```

Divide correlation plot by gvar regularized vs. non-regularized TODO: add diff_beta

```{r}
df_cor_grid_nonreg <- df_cor_full %>% 
  group_by(iter_bggm, iter_gvar) %>% 
  filter(dgp > dgp_cut) %>% 
  # this summarizes prior info etc., which is the same within a simulation condition
  # just a trick to keep it in the df
  dplyr::summarize(across(everything(),
                   ~mean(.))) %>% 
  pivot_longer(cols = c(contains("cor"), contains("diff")), values_to = "cor", names_to = "mat") %>%
  filter(is.na(lambda)) %>% 
  mutate(comb = paste0("R: ", rho_prior, ", B: ", beta_prior,
                       ", G: ", gamma_ebic)) %>% 
  # add linetype
  mutate(lty = ifelse(grepl("sel", mat), "select", "nonselect")) %>% 
  ungroup() %>% 
  ggplot(aes(x = n_tp, y = cor, col = mat))+
  geom_line(aes(linetype = lty))+
  theme_bw()+
  # scale_x_discrete(breaks = 1:5, labels = c("50", "100", "200", "400", "1000"))+
  facet_grid(dgp~comb)+
  # ggokabeito::scale_color_okabe_ito()+
  theme(strip.text.x = element_text(size = 6))+
  theme_compare()+
  labs(x = "Timepoints")


df_cor_grid_reg <- df_cor_full %>% 
  group_by(iter_bggm, iter_gvar) %>% 
  # this summarizes prior info etc., which is the same within a simulation condition
  # just a trick to keep it in the df
  filter(dgp >2) %>% 
  dplyr::summarize(across(everything(),
                   ~mean(.))) %>% 
  pivot_longer(cols = c(contains("cor"), contains("diff")), values_to = "cor", names_to = "mat") %>%
  filter(!is.na(lambda)) %>% 
  mutate(comb = paste0("R: ", rho_prior, ", B: ", beta_prior,
                       ", G: ", gamma_ebic)) %>% 
  # add linetype
  mutate(lty = ifelse(grepl("sel", mat), "select", "nonselect")) %>% 
  ungroup() %>% 
  ggplot(aes(x = n_tp, y = cor, col = mat))+
  geom_line(aes(linetype = lty))+
  theme_bw()+
  facet_grid(dgp~comb)+
  # ggokabeito::scale_color_okabe_ito
  theme_compare()+
  theme(strip.text.x = element_text(size = 6))


# Use NULL to create some space between plots
plot_cor_grid_sep <- cowplot::plot_grid(
  NULL, df_cor_grid_nonreg, NULL, df_cor_grid_reg,
  labels = c("", "Regularized","", "Non-Regularized"), ncol = 1,
  align = "v",
  rel_heights= c(0.05, 1, 0.05, 1),
  label_x = .01, label_y = 1.05
)

ggsave("plot_cor_grid_sep.svg", plot_cor_grid_sep, height = 15, width = 18, path = here::here("figures/"), device = "svg")


```

## Compare performance BGGM and graphicalVAR

### Plot comparison of both methods

```{r}
plot_eval_both <- df_eval_both %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # dplyr::select(c(dgp_ind, tp_ind, lambda, ebic, contains("prior"), contains("bias"),contains("rmse"))) %>%
  dplyr::select(c(dgp_ind, tp_ind, lambda, ebic, data_ind, contains("prior"), contains("bias"),contains("cor_beta"),
                  contains("cor_pcor"))) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  dplyr::group_by(dgp_ind, tp_ind, lambda, ebic, prior_comb) %>% 
  dplyr::summarize(across(c(contains("bias"),contains("cor_beta"), contains("cor_pcor")),
                   ~mean(., na.rm = TRUE))) %>% 
  pivot_wider(names_from = prior_comb, 
              values_from = c(contains("bggm"), contains("sel"))) %>% 
  pivot_longer(cols = c(contains("bias"), contains("cor_beta"), contains("cor_pcor")),
                        names_to = "stat") %>%
  mutate(method = case_when(
    stringr::str_detect(stat, "bggm_b0.2") ~ "BGGM narrow",
    stringr::str_detect(stat, "bggm_b1") ~ "BGGM wide",
    stringr::str_detect(stat, "gvar") ~ "graphicalVAR",
    stringr::str_detect(stat, "sel_b0.2") ~ "SEL narrow",
    stringr::str_detect(stat, "sel_b1") ~ "SEL wide"
  )) %>% 
  mutate(mat = case_when(
    stringr::str_detect(stat, "beta") ~ "Temporal",
    stringr::str_detect(stat, "pcor") ~ "Contemporaneous"
  )) %>% 
  mutate(stat = case_when(
    stringr::str_detect(stat, "bias") ~ "Bias",
    stringr::str_detect(stat, "rmse") ~ "RMSE",
    stringr::str_detect(stat, "cor_beta") ~ "Correlation",
    stringr::str_detect(stat, "cor_pcor") ~ "Correlation"
  )) %>% 
  # remove everything after first underscore
  # remove matrix from stat column
  mutate(stat = stringr::str_remove(stat, "_.*")) %>% 
  # add linetype
  mutate(lty = ifelse(grepl("SEL", method), "select", "nonselect")) %>% 
  # only take default values for now
  filter(is.na(lambda) & ebic == 0) %>% 
  ggplot(aes(x = tp_ind, y = value, col = method, group = method))+
  geom_line(aes(linetype = lty))+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat))+
  theme_bw()+
  scale_color_manual(values = cond_colors)+
  labs(x = "Timepoints",
       col = "Method",
       y = "",
       linetype = "Select")+
  theme_compare()+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

plot_eval_both

ggsave("plot_eval_both_cor.svg", plot_eval_both, height = 9, width = 12, path = here::here("figures/"), device = "svg")

```

#### Plot both with uncertainty
Now, only choose narrower prior.
New attempt with cowplot:
TODO add second prior!
```{r}
ls_data_both_stat <- df_eval_both %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  dplyr::select(c(dgp_ind, tp_ind, lambda, ebic, contains("prior"), contains("bias"),contains("cor_beta"),
                  contains("cor_pcor"), data_ind)) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b0.2_r0.3" | prior_comb == "b1_r0.5") %>% 
  dplyr::group_by(dgp_ind, tp_ind, lambda, ebic, prior_comb, data_ind) %>% 
  dplyr::select(!c(rho_prior, beta_prior)) %>% 
  pivot_wider(names_from = prior_comb,
              values_from = c(contains("bggm"), contains("sel"))) %>%
  pivot_longer(cols = c(contains("bias"), contains("cor_beta"), contains("cor_pcor")),
                        names_to = "stat") %>%
  mutate(method = case_when(
    stringr::str_detect(stat, "bggm_b0.2") ~ "BGGM narrow",
    stringr::str_detect(stat, "bggm_b1") ~ "BGGM wide",
    stringr::str_detect(stat, "gvar") ~ "graphicalVAR",
    stringr::str_detect(stat, "sel_b0.2") ~ "SEL narrow",
    stringr::str_detect(stat, "sel_b1") ~ "SEL wide"
  )) %>% 
  mutate(mat = case_when(
    stringr::str_detect(stat, "beta") ~ "Temporal",
    stringr::str_detect(stat, "pcor") ~ "Contemporaneous"
  )) %>% 
  mutate(stat = case_when(
    stringr::str_detect(stat, "bias") ~ "Bias",
    stringr::str_detect(stat, "rmse") ~ "RMSE",
    stringr::str_detect(stat, "cor_beta") ~ "Correlation",
    stringr::str_detect(stat, "cor_pcor") ~ "Correlation"
  )) %>% 
  # remove everything after first underscore
  # remove matrix from stat column
  mutate(stat = stringr::str_remove(stat, "_.*")) %>% 
  # only take default values for now
  filter(is.na(lambda) & ebic == 0) %>% 
  # Split based on statistic to obtain different y-axes
  split(., .$stat)

ls_eval_both_plots <- list()    
ls_eval_both_plots[[1]] <- ggplot(ls_data_both_stat$Bias, aes(x = tp_ind, y = value, col = method))+
  geom_boxplot(outlier.size = 0.5, outlier.alpha = 0.4, outlier.color = "grey")+
  ggh4x::facet_nested(as.factor(dgp_ind) ~  as.factor(stat) +  as.factor(mat))+
  scale_color_manual(values = cond_colors)+
  # scale_color_manual(values = cond_colors, guide = "none")+
  labs(x = "Timepoints",
       col = "Method",
       y = "",
       linetype = "Select")+
  theme_compare()+
  scale_y_continuous(limits = c(0,.2), breaks = c(0, .05, .1, .15, .2))+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        strip.text.y = element_blank(),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

ls_eval_both_plots[[2]] <- ggplot(ls_data_both_stat$Correlation, aes(x = tp_ind, y = value, col = method))+
  geom_boxplot(outlier.size = 0.5, outlier.alpha = 0.4, outlier.color = "grey")+
  ggh4x::facet_nested(as.factor(dgp_ind) ~  as.factor(stat) +  as.factor(mat))+
  scale_color_manual(values = cond_colors)+
  # scale_color_manual(values = cond_colors, guide = "none")+
  labs(x = "Timepoints",
       col = "Method",
       y = "",
       linetype = "Select")+
  theme_compare()+
  scale_y_continuous(limits = c(0,1), breaks = c(0, .25, .5, .75, 1))+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4)))

  


plot_eval_both_box <- patchwork::wrap_plots(ls_eval_both_plots) + 
  patchwork::plot_layout(guides = "collect") & theme(legend.position = "top")

ggsave("plot_eval_both_cor_box.svg", plot_eval_both_box, height = 9, width = 12, path = here::here("figures/"), device = "svg")

```



### Focus on selection methods
Here, focus on selection methods and investigate specificity, sensitivity etc.
```{r}
plot_eval_both_select <- df_eval_both %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # dplyr::select(c(dgp_ind, tp_ind, lambda, ebic, contains("prior"), contains("bias"),contains("rmse"))) %>%
  dplyr::select(c(dgp_ind, tp_ind, lambda, ebic, contains("prior"), contains("spec"),contains("sens"),
                  contains("zeros"))) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b0.2_r0.3") %>% 
  dplyr::group_by(dgp_ind, tp_ind, lambda, ebic, prior_comb) %>% 
  pivot_longer(cols = c(contains("zeros"), contains("spec"), contains("sens")),
                        names_to = "stat") %>%
  mutate(method = case_when(
    stat == "zeros_beta" ~ "graphicalVAR",
    stat == "zeros_pcor" ~ "graphicalVAR",
    stringr::str_detect(stat, "gvar") ~ "graphicalVAR",
    stringr::str_detect(stat, "sel") ~ "SEL narrow",
    stringr::str_detect(stat, "bggm") ~ "SEL narrow",
  )) %>% 
  mutate(mat = case_when(
    stringr::str_detect(stat, "beta") ~ "Temporal",
    stringr::str_detect(stat, "pcor") ~ "Contemporaneous"
  )) %>% 
  mutate(stat = case_when(
    stringr::str_detect(stat, "sens") ~ "Sensitivity",
    stringr::str_detect(stat, "spec") ~ "Specificity",
    stringr::str_detect(stat, "zeros") ~ "Zeros"
  )) %>% 
  # remove everything after first underscore
  # remove matrix from stat column
  mutate(stat = stringr::str_remove(stat, "_.*")) %>% 
  # add linetype
  # mutate(lty = ifelse(grepl("SEL", method), "select", "nonselect")) %>%
  # only take default values for gvar now
  filter(is.na(lambda) & ebic == 0) %>% 
  filter(stat != "Zeros") %>%
  ggplot(aes(x = tp_ind, y = value, col = method))+
  geom_boxplot(outlier.size = 0.5, outlier.alpha = 0.4, outlier.color = "grey")+
  ggh4x::facet_nested(dgp_ind ~ as.factor(stat) + as.factor(mat))+
  theme_bw()+
  scale_color_manual(values = cond_colors)+
  labs(x = "Timepoints",
       col = "Method",
       y = "", 
       linetype = "Selection")+
  theme_compare()+
  theme(strip.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3), 
                                           hjust = 0.5),
        strip.text.x.top = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.3),
                                                 hjust = 0.5),
        legend.text = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        legend.title = ggplot2::element_text(face = "bold", size = ggplot2::rel(1.2)),
        # panel.border = element_rect(color = "#D5D8DC", fill = NA, size = 1),
        panel.spacing.y = ggplot2::unit(1.6, "lines"),
        panel.spacing.x = ggplot2::unit(1.6, "lines"),
        axis.text.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.2)),
        axis.title.x = ggplot2::element_text(face = "plain", size = ggplot2::rel(1.4))) + 
  # reorder legend
  guides(linetype = guide_legend(order = 1),
         col = guide_legend(order = 0))
plot_eval_both_select

ggsave("plot_eval_both_select.svg", plot_eval_both_select, height = 9, width = 12, path = here::here("figures/"), device = "svg")
```


Now with standard errors:
```{r}




```






### Focus on nonselect methods

TODO Maybe omit RMSE here!
```{r}
plot_eval_both_nonselect <- df_eval_both %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  dplyr::select(c(dgp_ind, tp_ind, lambda, ebic, contains("bias"), contains("rmse"), contains("prior"))) %>% 
  dplyr::select(!contains("sel")) %>% 
  # use non-lasso graphicalVAR
  filter(lambda == 0 & ebic == 0) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  dplyr::select(!c(rho_prior, beta_prior)) %>% 
  dplyr::group_by(dgp_ind, tp_ind, lambda, ebic, prior_comb) %>% 
  pivot_wider(names_from = prior_comb,
              values_from = c(contains("bggm"))) %>%
  pivot_longer(cols = c(contains("bias"), contains("rmse")),
                        names_to = "stat") %>%

  mutate(method = case_when(
    stringr::str_detect(stat, "gvar") ~ "graphicalVAR",
    stringr::str_detect(stat, "bggm_b0.2") ~ "BGGM narrow",
    stringr::str_detect(stat, "bggm_b1") ~ "BGGM wide"
  )) %>% 
  mutate(mat = case_when(
    stringr::str_detect(stat, "beta") ~ "Temp.",
    stringr::str_detect(stat, "pcor") ~ "Contemp."
  )) %>% 
  mutate(stat = case_when(
    stringr::str_detect(stat, "bias") ~ "Bias",
    stringr::str_detect(stat, "rmse") ~ "RMSE"
  )) %>% 
  ggplot(aes(x = tp_ind, y = value, col = method))+
  geom_boxplot(outlier.size = 0.5, outlier.alpha = 0.4, outlier.color = "grey")+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat),
                      scales = "free")+
  theme_bw()+
  # ggokabeito::scale_color_okabe_ito()+
  scale_color_manual(values = cond_colors)+
  labs(caption = "graphicalVAR without LASSO",
       x = "Timepoints",
       col = "Method",
       y = "")+
  theme_compare()
plot_eval_both_nonselect

ggsave("plot_eval_both_nonselect.svg", plot_eval_both_nonselect, height = 7, width = 15, path = here::here("figures/"), device = "svg")

```

### Coverage and interval width BGGM

Create a plot to investigate credible intervals of BGGM
Now with uncertainty
```{r}
plot_eval_credible <- df_eval_both %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # only take default values for gvar now to filter out redundant information
  filter(is.na(lambda) & ebic == 0) %>% 
  dplyr::select(-c(lambda,ebic)) %>% 
  dplyr::select(c(dgp_ind, tp_ind, contains("prior"), contains("width"),contains("cover"))) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  dplyr::group_by(dgp_ind, tp_ind, prior_comb) %>% 
  # convert coverage into proportion
  mutate(n_nodes = ifelse(dgp_ind == "Simulated\nChain 8N", 8, 6)) %>% 
  mutate(across(contains("sum_cover_beta"),
                ~ ./n_nodes^2)) %>% 
  # divide by number of unique off-diagonal elements
  mutate(across(contains("sum_cover_pcor"),
                ~ ./((n_nodes/2)*(n_nodes-1)))) %>% 
  # dplyr::summarize(across(c(contains("width"), contains("cover")),
  #                  ~mean(., na.rm = TRUE))) %>% 
  pivot_longer(cols = c(contains("width"), contains("cover")),
                        names_to = "stat") %>%
  mutate(mat = case_when(
    stringr::str_detect(stat, "beta") ~ "Temp.",
    stringr::str_detect(stat, "pcor") ~ "Contemp."
  )) %>% 
  # add line for coverage
  mutate(intercept = case_when(
    stringr::str_detect(stat, "cover_beta_0.9$") ~ 0.9,
    stringr::str_detect(stat, "cover_beta_0.95") ~ 0.95,
    stringr::str_detect(stat, "cover_beta_0.99") ~ 0.99,
    stringr::str_detect(stat, "cover_pcor_0.9$") ~ 0.9,
    stringr::str_detect(stat, "cover_pcor_0.95") ~ 0.95,
    stringr::str_detect(stat, "cover_pcor_0.99") ~ 0.99,
    .default = 0
  )) %>% 
  # Little trick to not show horizontal line for the width facets
  mutate(line_alpha = case_when(
    stringr::str_detect(stat, "cover") ~ 1,
    stringr::str_detect(stat, "width") ~ 0
  )) %>% 
    mutate(stat = case_when(
    stringr::str_detect(stat, "width_beta_0.9$") ~ "Width 0.9",
    stringr::str_detect(stat, "width_beta_0.95") ~ "Width 0.95",
    stringr::str_detect(stat, "width_beta_0.99") ~ "Width 0.99",
    stringr::str_detect(stat, "width_pcor_0.9$") ~ "Width 0.9",
    stringr::str_detect(stat, "width_pcor_0.95") ~ "Width 0.95",
    stringr::str_detect(stat, "width_pcor_0.99") ~ "Width 0.99",
    stringr::str_detect(stat, "cover_beta_0.9$") ~ "Coverage 0.9",
    stringr::str_detect(stat, "cover_beta_0.95") ~ "Coverage 0.95",
    stringr::str_detect(stat, "cover_beta_0.99") ~ "Coverage 0.99",
    stringr::str_detect(stat, "cover_pcor_0.9$") ~ "Coverage 0.9",
    stringr::str_detect(stat, "cover_pcor_0.95") ~ "Coverage 0.95",
    stringr::str_detect(stat, "cover_pcor_0.99") ~ "Coverage 0.99",
  )) %>% 
  
  # Proper names for prior
    mutate(prior_comb = case_when(
    stringr::str_detect(prior_comb , "b0.2") ~ "BGGM narrow",
    stringr::str_detect(prior_comb , "b1") ~ "BGGM wide"
  )) %>% 
  dplyr::filter(!grepl("Width", stat)) %>% 
  ggplot(aes(x = tp_ind, y = value, col = prior_comb, group = prior_comb))+
  geom_hline(aes(yintercept = intercept, alpha = line_alpha), 
             col = "#D5D8DC", show.legend = FALSE)+
  geom_boxplot(outlier.size = 0.5, outlier.alpha = 0.4, outlier.color = "grey")+
  scale_y_continuous(limits = c(.5,1), breaks = c(.5, .6, .7, .8, .9, 1))+
  ggh4x::facet_nested(as.factor(dgp_ind) ~ as.factor(stat) + as.factor(mat))+
  scale_color_manual(values = cond_colors)+
  labs(x = "Timepoints",
       col = "Priors",
       y = "")+
  theme_compare()

plot_eval_credible 
ggsave("plot_eval_credible.svg", plot_eval_credible, height = 7, width = 12, path = here::here("figures/"), device = "svg")

```



Obtain numerical results:
```{r}
df_eval_both %>% 
  # delete older dgps
  filter(dgp_ind > dgp_cut) %>%
  # only take default values for gvar now to filter out redundant information
  filter(is.na(lambda) & ebic == 0) %>% 
  dplyr::select(-c(lambda,ebic)) %>% 
  dplyr::select(c(dgp_ind, tp_ind, contains("prior"), contains("width"),contains("cover"))) %>% 
  # mutate tp_ind into factor
  mutate(tp_ind = fct_recode(as_factor(as.character(tp_ind)), !!!tp_levels)) %>% 
  # mutate dgp_ind into factor
  mutate(dgp_ind = fct_recode(as_factor(as.character(dgp_ind)), !!!dgp_levels)) %>% 
  mutate(prior_comb = paste0("b", beta_prior,  "_r", rho_prior)) %>% 
  filter(prior_comb == "b1_r0.5" | prior_comb == "b0.2_r0.3") %>% 
  dplyr::group_by(dgp_ind, tp_ind, prior_comb) %>% 
  # convert coverage into proportion
  mutate(n_nodes = ifelse(dgp_ind == "Simulated\nChain 8N", 8, 6)) %>% 
  mutate(across(contains("sum_cover_beta"),
                ~ ./n_nodes^2)) %>% 
  # divide by number of unique off-diagonal elements
  mutate(across(contains("sum_cover_pcor"),
                ~ ./((n_nodes/2)*(n_nodes-1)))) %>% 
  dplyr::summarize(across(c(contains("width"), contains("cover")),
                   ~mean(., na.rm = TRUE))) %>% 
  pivot_longer(cols = c(contains("width"), contains("cover")),
                        names_to = "stat") %>%
  mutate(mat = case_when(
    stringr::str_detect(stat, "beta") ~ "Temp.",
    stringr::str_detect(stat, "pcor") ~ "Contemp."
  )) %>% 
  filter(grepl("sum_cover", stat)) %>% 
  # extract nominal CI value
  mutate(ci_nominal = as.numeric(str_extract(stat, "\\d+\\.\\d+$"))) %>% 
  mutate(ci_nominal_diff = value - ci_nominal) %>% 
  # group_by(prior_comb, tp_ind, stat, dgp_ind) %>% 
  # dplyr::summarize(mean_diff = mean(ci_nominal_diff)) %>% 
  ungroup() %>% 
  dplyr::summarize(median_diff = stats::median(abs(ci_nominal_diff)))
  

```

## Average model across simulation fits

Find averaged model across 1000 iterations in one condition.

```{r}
# BGGM
pcor_list <- lapply(fit_bggm[[30]], function(x)
  return(x$pcor_mu))

pcor_bggm <- apply(simplify2array(pcor_list), 1:2, mean)
diag(pcor_bggm) <- rep(0, 6)
options(scipen = 10)
pcor_bggm

beta_list <- lapply(fit_bggm[[70]], function(x)
  return(x$beta_mu))

apply(simplify2array(beta_list), 1:2, mean)


# gVAR

PCC_gvar_list <- lapply(l_res_gvar[[30]], function(x)
  return(x$PCC))

round(apply(simplify2array(PCC_gvar_list), 1:2, mean),3)

beta_gvar_list <- lapply(l_res_gvar[[30]], function(x)
  return(t(x$beta[,-1])))

round(apply(simplify2array(beta_gvar_list), 1:2, mean),3)


```
