---
title: "bggm-var-investigation"
author: "Bj√∂rn Siepe"
date: "2022-11-18"
output: html_document
---
In this file, I investigate some of the properties of BGGM var_estimate. 
Does it actually work well? If so, the following should be true.
1. It should perform regularization as it says.
2. It should recover roughly the same estimate as, e.g., graphicalVAR. 


# Test regularization
```{r}
set.seed(2022)
compgraph <- randomGVARmodel(Nvar = 6, probKappaEdge = 0.4, probBetaEdge = .2)
dat <- as.data.frame(graphicalVARsim(200, beta = compgraph$beta, kappa = graph$kappa))
res <- BGGM::var_estimate(dat,
                          beta_sd = 1)
res2 <- BGGM::var_estimate(dat,
                           beta_sd = 0.1)


# Try the same for rho
res3 <- BGGM::var_estimate(dat,
                          rho_sd = 0.5)
res4 <- BGGM::var_estimate(dat,
                          rho_sd = 0.05)



```

# Compare with GraphicalVAR

For now, just simulate 100 datasets from the same DGP. 
```{r generate-data}
# Storage
l_gvardata <- list()

# Simulation conditions
n_ind <- 200   # number of individuals (so models to create)
n_tp <- 150     # number of timepoints per time series

ncores = parallel::detectCores() - 4
cl = makeCluster(ncores)
registerDoParallel(cl)

l_gvardata <- sim_raw_parallel(dgp = compgraph, n = n_ind, 
                                tp = n_tp, means = 0,
                                standardize = TRUE)

stopCluster(cl)





```

```{r fit-models}
# Model specifics
rho_sd <- 0.5
beta_sd <- 1
seed <- 2022
n_iter <- 5000

l_compres <- list()
ncores = parallel::detectCores() - 4
cl = makeCluster(ncores)
registerDoParallel(cl)

l_compres$bggm <- fit_var_parallel(data = l_gvardata, n = n_ind,
                 rho_prior = rho_sd, beta_prior = beta_sd, seed = seed,
                 iterations = n_iter)

l_compres$gvar <- foreach(i = seq(n_ind), .packages = "graphicalVAR") %dopar% {
  tmp_res <- graphicalVAR(data = l_gvardata[[i]]$data, 
               lambda_beta = 0,
               lambda_kappa = 0, 
               scale = TRUE, 
               gamma = 0)
  
  tmp_res
  
}

stopCluster(cl)


```



Now we can compare the results. What do we look at? Due to no regularization, do not look at true positives/false positives here. 
- difference from data-generating process


TODO: Is it fine not to look at the intercepts? This might be important. 
TODO: Do I need the transpose?
TODO: Add correlations


```{r compare-results}

# TODO: Do I need to takek absolute differences here or does it work this way?
compare_dgp <- function(true, 
                        est_bggm,
                        comp_gvar = TRUE,
                        est_gvar,
                        n = n_ind){
  
  # replicate dgp 
  dgp <- list()
  for(i in 1:n){
    dgp[[i]] <- list()
    dgp[[i]]$beta <- true$beta
    dgp[[i]]$kappa <- true$kappa
    dgp[[i]]$PCC <- true$PCC
  }
  
  # storage
  l_diff_beta <- list()
  l_diff_pcor <- list()
  out <- list()
  ## Differences
  # Look at difference to true values for bggm
  l_diff_beta[["true_bggm"]] <- map2(dgp, est_bggm, .f = function(x,y){x$beta-t(y$beta_mu)})
  l_diff_pcor[["true_bggm"]] <- map2(dgp, est_bggm, .f = function(x,y){x$PCC-y$pcor_mu})
  
  if(isTRUE(comp_gvar)){
  # Look at difference to true values for gvar
  # delete intercepts
  l_diff_beta[["true_gvar"]] <- map2(dgp, est_gvar, .f = function(x,y){x$beta-y$beta[,-1]})
  l_diff_pcor[["true_gvar"]] <- map2(dgp, est_gvar, .f = function(x,y){x$PCC-y$PCC})
  
  # Look at difference between bggm and gvar
  # delete intercepts
  l_diff_beta[["bggm_gvar"]] <- map2(est_bggm, est_gvar, .f = function(x,y){t(x$beta_mu)-y$beta[,-1]})
  l_diff_pcor[["bggm_gvar"]] <- map2(est_bggm, est_gvar, .f = function(x,y){x$pcor_mu-y$PCC})
    
  }

  
  # Aggregate differences
  out[["diff_beta"]] <- lapply(l_diff_beta, function(x){apply(simplify2array(x), 1:2, mean)})
  out[["diff_pcor"]] <- lapply(l_diff_pcor, function(x){apply(simplify2array(x), 1:2, mean)})
  
  ## Correlations
  # Look at correlations between bggm and gvar
  # # delete intercepts
  # 
  # out[["cor"]] <- map2(est_bggm, est_gvar, .f = function(x,y){cor(t(x$beta_mu)-y$beta[,-1])})
  # 
  # # aggregate correlations
  
  out
  
}


comp_res <- compare_dgp(true = compgraph, est_bggm = l_compres$bggm, est_gvar = l_compres$gvar, n = 200)


```

Works pretty well for n = 200 and one graph. Default priors seem to be okay, only has convergence issues in some cases.  



