---
title: "bggm-var-investigation"
author: "Bj√∂rn Siepe"
date: "2022-11-18"
output: html_document
---
In this file, I investigate some of the properties of BGGM var_estimate. 
Does it actually work well? If so, the following should be true.
1. It should perform regularization as it says.
2. It should recover roughly the same estimate as, e.g., graphicalVAR. 


```{r}
library(tidyverse)
library(doParallel)
library(parallel)
library(foreach)
library(BGGM)
library(graphicalVAR)
library(cowplot)
source("aux_funs.R")

seed = 2022
set.seed(seed)
```



# Simulation study

## Data Generation
Just use "truegraph" data from main simulation study for now. 
TODO: Download this from the server. 
```{r}
l_raw <- readRDS(here::here("output/l_raw.RDS"))
l_graphs <- readRDS(here::here("data/l_graphs.RDS"))
# 
# # Only truegraph
# l_dgp <- list()
# l_dgp$graph1 <- lapply(l_raw$graph1, function(x){
#   y <- x$truegraph
#   y
# })
# l_dgp$graph2 <- lapply(l_raw$graph2, function(x){
#   y <- x$truegraph
#   y
# })
# l_dgp$graph3 <- lapply(l_raw$graph3, function(x){
#   y <- x$truegraph
#   y
# })




```


Simulate data anew.
```{r}
# Simulation conditions
n_ind <- 1000 # number of individuals(so models to create) 
n_tp <- c(50,100,200,400,1000) # number of timepoints
n_postds <- 1000 # number of posterior datasets
seed <- 2022

# Bayesian model parameters
rho_sd <- 0.5      # Prior for partial correlations
beta_sd <- 1       # Prior for regression matrix
seed <- 2022
n_iter <- 50000


# Think about if I actually need to standardize here
# because everything will be standardized by var_estimate anyway
l_raw <- readRDS(l_raw, file = here::here("data/l_raw1000.RDS"))


# Changed: instead of n_ind, we create n_postds datasets 
# because some models don't converge
set.seed(seed)
before_simraw <- Sys.time()
ncores = 40
cl = makeCluster(ncores)
registerDoParallel(cl)
# l_raw <- list()
# l_raw$graph3 <- l_raw$graph2 <- l_raw$graph1 <-  list()
for(t in seq_along(n_tp)){
  # l_raw$graph1[[t]] <- list()
  # l_raw$graph1[[t]] <- sim_raw_parallel(dgp = l_graphs$graph1,
  #                                   n = n_postds,
  #                                   tp = n_tp[t],
  #                                   seed = seed,
  #                                   means = 0,
  #                                   standardize = TRUE)
  # 
  # l_raw$graph2[[t]] <- list()
  # l_raw$graph2[[t]] <- sim_raw_parallel(dgp = l_graphs$graph2,
  #                                   n = n_postds,
  #                                   tp = n_tp[t],
  #                                   seed = seed,
  #                                   means = 0,
  #                                   standardize = TRUE)
  # l_raw$graph3[[t]] <- list()
  # l_raw$graph3[[t]] <- sim_raw_parallel(dgp = l_graphs$graph3,
  #                                   n = n_postds,
  #                                   tp = n_tp[t],
  #                                   seed = seed,
  #                                   means = 0,
  #                                   standardize = TRUE)
  # l_raw$graph4[[t]] <- sim_raw_parallel(dgp = l_graphs$graph4,
  #                                   n = n_postds,
  #                                   tp = n_tp[t],
  #                                   seed = seed,
  #                                   means = 0,
  #                                   standardize = TRUE)
  
  l_raw$graph5[[t]] <- sim_raw_parallel(dgp = l_graphs$graph5,
                                    n = n_postds,
                                    tp = n_tp[t],
                                    seed = seed,
                                    means = 0,
                                    standardize = TRUE)
  
  
  
}

stopCluster(cl)


# saveRDS(l_raw, file = here::here("data/l_raw1000.RDS"))



```





## Estimation
Estimate both graphicalVAR in default settings as well as BGGM with varying priors.

Next steps here: load results, then figure out which files haven't been done yet
```{r}
# Priors
dgp_names <- c("graph1", "graph2", "graph3", "graph4", "graph5")
dgp <- c(1,2,3,4,5)
rho_sd <- c(0.1, 0.3, 0.5)
beta_sd <- c(0.2, 0.5, 1)
n_tp <- c(50, 100, 200, 400, 1000) 
tp_cond <- c(1,2,3,4,5)   # different tp conditions

cond_grid <- expand.grid(dgp = dgp,
                         n_tp = tp_cond,
                         rho_prior = rho_sd, 
                         beta_prior = beta_sd)
n_iter <- 50000
seed <- 2022
set.seed(seed)



# Estimating for each model 
# store BGGM results under "nonselect"
ncores = 50
cl = makeCluster(ncores)
clusterExport(cl = cl, "summarize_post")
registerDoParallel(cl)
l_res_bggm <- list()



for(n in 1:nrow(cond_grid)) {
  dgp_ind <- as.numeric(cond_grid[n, "dgp"])
  tp_ind <- as.numeric(cond_grid[n, "n_tp"])
  r_sd <- as.numeric(cond_grid[n, "rho_prior"])
  b_sd <- as.numeric(cond_grid[n, "beta_prior"])
  print(paste0(nrow(cond_grid)-n, " to go!"))
  l_res_bggm[[n]]  <- fit_var_parallel_merged(l_raw[[dgp_ind]][[tp_ind]],
                          rho_prior = r_sd,
                          beta_prior = b_sd,
                          iterations = n_iter,
                          n = 1000,
                          nds = 1000,
                          seed = seed,
                          get_kappa = FALSE, 
                          summarize_post = TRUE,
                          cred_int = c(0.9, 0.95, 0.99),
                          pruneresults = FALSE,
                          save_files = FALSE,
                          multigroup = FALSE,
                          select = TRUE)
    

  
}
stopCluster(cl)

# Attach the simulation conditions
for(m in 1:nrow(cond_grid)){
  for(i in 1:length(l_res_bggm[[m]])){
    l_res_bggm[[m]][[i]]$sim_cond <- cond_grid[m,]
  }
}

# saveRDS(l_res_bggm, here::here("output/bggm-var-sim-res_1703.Rds"))
# l_res_bggm <- readRDS(here::here("output/bggm-var-sim-res_1703.Rds"))

rm(l_res)


```
### Fit graphicalVAR
```{r}
# Conditions of varying sparsity
gamma_ebic <- c(0, 0.5)      # EBIC hyperparameter
lambda <- c(NA, 0)


cond_grid_gvar <- expand.grid(dgp = dgp,
                         n_tp = tp_cond,
                         gamma_ebic = gamma_ebic,
                         lambda = lambda)


ncores = 50
cl = makeCluster(ncores)
clusterExport(cl = cl, "fit_graphicalvar_parallel")
registerDoParallel(cl)
l_res_gvar <- list()
time_before_gvar <- Sys.time()
for(n in 1:nrow(cond_grid_gvar)) {
  dgp_ind <- as.numeric(cond_grid_gvar[n, "dgp"])
  tp_ind <- as.numeric(cond_grid_gvar[n, "n_tp"])
  gamma_ebic <- as.numeric(cond_grid_gvar[n, "gamma_ebic"])
  lambda <- as.numeric(cond_grid_gvar[n, "lambda"])
  print(paste0(nrow(cond_grid_gvar)-n, " to go!"))
  
  # unregularized
  if(!is.na(lambda)){
   l_res_gvar[[n]]  <- fit_graphicalvar_parallel(l_raw[[dgp_ind]][[tp_ind]],
                                                  n = 1000,
                                                  gamma = gamma_ebic,
                                                  nLambda = 50, 
                                                  pruneresults = TRUE, 
                                                  lambda_beta = lambda,
                                                  lambda_kappa = lambda)
                            
  }
  # regularized
  if(is.na(lambda)){
   l_res_gvar[[n]]  <- fit_graphicalvar_parallel(l_raw[[dgp_ind]][[tp_ind]],
                                                 n = 1000,
                                                 gamma = gamma_ebic,
                                                 nLambda = 50, 
                                                 pruneresults = TRUE)
    
  }
    

  
}
stopCluster(cl)

time_after_gvar <- Sys.time() - time_before_gvar


# Attach the simulation conditions
for(m in 1:nrow(cond_grid_gvar)){
  for(i in 1:length(l_res_gvar[[m]])){
    l_res_gvar[[m]][[i]]$sim_cond <- cond_grid_gvar[m,]
  }
}

# saveRDS(l_res_gvar, here::here("output/graphicalvar-sim-res_1703.Rds"))
# l_res_gvar <- readRDS(here::here("output/graphicalvar-sim-res_1703.Rds"))

    
# Delete rows that were accidentally created (looping over rows of cond_grid
# instead of cond_grid_gvar)

# l_res_gvar <- l_res_gvar[1:nrow(cond_grid_gvar)]



```




## Evaluation
Evaluate both with and without graph selection.

```{r}
## BGGM
l_eval_bggm <- lapply(l_res_bggm, function(x){
  res <- lapply(x, eval_bggm)
  return(res)
})
df_eval_bggm <- purrr::flatten(l_eval_bggm)
df_eval_bggm <- dplyr::bind_rows(df_eval_bggm)
# Pivot CIs wider
df_eval_bggm_wide <- df_eval_bggm %>% 
  tidyr::unpack(cols = ci) %>% 
  pivot_wider(names_from = ci, values_from = c(sum_cover_beta, sum_cover_pcor,
                                               width_beta, width_pcor))
rm(df_eval_bggm)
rm(l_eval_bggm)

## GVAR
l_eval_gvar <- list()
for(i in 1:nrow(cond_grid_gvar)){
  l_eval_gvar[[i]] <- lapply(l_res_gvar[[i]], eval_gvar)
}

# Convert to dataframe
df_eval_gvar <- purrr::flatten(l_eval_gvar)
df_eval_gvar <- dplyr::bind_rows(df_eval_gvar)
rm(l_eval_gvar)

```


#### Plot BGGM
```{r}
df_eval_bggm_summary <- df_eval_bggm %>% 
  group_by(dgp_ind, tp_ind, rho_prior, beta_prior) %>% 
  # convert coverage into proportion
  mutate(across(contains("sum_cover_beta"),
                ~ ./36)) %>% 
  # divide by number of unique off-diagonal elements
  mutate(across(contains("sum_cover_pcor"),
                ~ ./15)) %>% 
  summarize(across(c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                   bias_beta_sel, bias_pcor_sel, cor_beta_sel,                                    cor_pcor_sel, spec_beta, spec_pcor,
                   sens_beta, sens_pcor, contains("sum_cover")), 
                   .fns = list(mean = mean, 
                               sd = sd,
                               se = ~ sd / sqrt(sum(!is.na(.x))), 
                               lower = ~ mean - 1.96*se, 
                               upper = ~ mean + 1.96*se, 
                               median = ~ median(.x, na.rm = TRUE))))


plot_eval_bggm <- df_eval_bggm_wide %>% 
  group_by(dgp_ind, tp_ind, rho_prior, beta_prior) %>% 
  # convert coverage into proportion
  mutate(across(contains("sum_cover_beta"),
                ~ ./36)) %>% 
  # divide by number of unique off-diagonal elements
  mutate(across(contains("sum_cover_pcor"),
                ~ ./15)) %>% 
  summarize(across(c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                   bias_beta_sel, bias_pcor_sel, cor_beta_sel,                              cor_pcor_sel, spec_beta, spec_pcor,
                   sens_beta, sens_pcor, contains("sum_cover")), 
                   ~mean(.))) %>% 
  pivot_longer(cols = c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                   bias_beta_sel, bias_pcor_sel, cor_beta_sel,                              cor_pcor_sel, spec_beta, spec_pcor,
                   sens_beta, sens_pcor, contains("sum_cover")), names_to = "stat", 
               values_to = "value") %>% 
  mutate(prior_comb = paste0("rho = ", rho_prior, ", beta = ", beta_prior)) %>% 
  ungroup() %>% 
  ggplot(aes(x = tp_ind, y = value, col = prior_comb)) + 
  facet_grid(dgp_ind ~ stat) + 
  geom_line() + 
  theme_bw()+
  ylim(0,1)
  # ggokabeito::scale_color_okabe_ito()

ggsave("plot_eval_bggm.svg", plot_eval_bggm, path = here::here("figures/"), device = "svg", width = 20, height = 9)  

```

### Plot GVAR

Plot results
```{r}
plot_eval_gvar <- df_eval_gvar %>% 
  mutate(lambda = as.character(lambda)) %>% 
  mutate(lambda = tidyr::replace_na(lambda, "default")) %>% 
  group_by(dgp_ind, tp_ind, ebic, lambda) %>% 
  summarize(across(c(bias_beta, bias_pcor, cor_beta, cor_pcor,
                     spec_beta, spec_pcor,
                     sens_beta, sens_pcor),
                   ~mean(.))) %>% 
  pivot_longer(cols = (c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                         spec_beta, spec_pcor,
                         sens_beta, sens_pcor)), 
               names_to = "stat", values_to = "value") %>% 
   mutate(ebic_lambda_comb = paste0("Gamma: ", ebic, ", Lambda = ", lambda)) %>% 
  ungroup() %>% 
  ggplot(aes(x = tp_ind, y = value, col = ebic_lambda_comb))+
  geom_line()+
  facet_grid(dgp_ind ~ stat) + 
  ylim(0,1)+
  theme_bw()
  # ggokabeito::scale_colour_okabe_ito()

ggsave("plot_eval_gvar.svg", plot_eval_gvar, path = here::here("figures/"), device = "svg", width = 16, height = 9)  

```



## Correlate BGGM and graphicalVAR

BGGM and GVAR simulations have different amount of conditions, so I need to match them on their DGP + number of time points first
```{r}
cond_grid_full <- cond_grid %>% 
  mutate(iter_bggm = dplyr::row_number()) %>% 
  left_join(cond_grid_gvar %>% mutate(iter_gvar = dplyr::row_number()),
            by = c("dgp", "n_tp"))

# loop through all conditions and compute correlations
l_cor <- list()
for(i in 1:nrow(cond_grid_full)){
  iter_bggm <- cond_grid_full[i, "iter_bggm"]
  iter_gvar <- cond_grid_full[i, "iter_gvar"]
  
  l_cor[[i]] <- mapply(compare_bggm_gvar, l_res_bggm[[iter_bggm]], l_res_gvar[[iter_gvar]], SIMPLIFY = FALSE)
  
  # add iteration information
  l_cor[[i]] <- lapply(l_cor[[i]], function(x){
    x$iter_bggm <- iter_bggm
    x$iter_gvar <- iter_gvar
    return(x)
  })
}

l_cor_flat <- flatten(l_cor)
df_cor <- dplyr::bind_rows(l_cor_flat)

# NAs are zeroes 
df_cor_full <- df_cor %>% 
  mutate(across(contains("cor"),
                ~tidyr::replace_na(., replace = 0))) %>% 
  left_join(cond_grid_full, by = c("iter_bggm", "iter_gvar"))




```



Visualize results across simulation conditions. 
```{r}
df_cor_grid  <- df_cor_full %>% 
  group_by(iter_bggm, iter_gvar) %>% 
  # this summarizes prior info etc., which is the same within a simulation condition
  # just a trick to keep it in the df
  summarize(across(everything(),
                   ~mean(.))) %>% 
  pivot_longer(cols = contains("cor"), values_to = "cor", names_to = "mat") %>% 
  mutate(comb = paste0("R: ", rho_prior, ", B: ", beta_prior,
                       ", G: ", gamma_ebic, ", L : ", lambda)) %>% 
  ungroup() %>% 
  ggplot(aes(x = as.factor(n_tp), y = cor, col = mat))+
  geom_line()+
  theme_bw()+
  facet_grid(dgp~comb)+
  # ggokabeito::scale_color_okabe_ito()+
  theme(strip.text.x = element_text(size = 3))


ggsave("df_cor_grid.svg", df_cor_grid, height = 5, width = 25, path = here::here("figures/"),
       device = "svg")


```

Divide correlation plot by gvar regularized vs. non-regularized
```{r}
df_cor_grid_nonreg <- df_cor_full %>% 
  group_by(iter_bggm, iter_gvar) %>% 
  # this summarizes prior info etc., which is the same within a simulation condition
  # just a trick to keep it in the df
  summarize(across(everything(),
                   ~mean(.))) %>% 
  pivot_longer(cols = contains("cor"), values_to = "cor", names_to = "mat") %>%
  filter(is.na(lambda)) %>% 
  mutate(comb = paste0("R: ", rho_prior, ", B: ", beta_prior,
                       ", G: ", gamma_ebic)) %>% 
  # add linetype
  mutate(lty = ifelse(grepl("sel", mat), "select", "nonselect")) %>% 
  ungroup() %>% 
  ggplot(aes(x = n_tp, y = cor, col = mat))+
  geom_line(aes(linetype = lty))+
  theme_bw()+
  # scale_x_discrete(breaks = 1:5, labels = c("50", "100", "200", "400", "1000"))+
  facet_grid(dgp~comb)+
  # ggokabeito::scale_color_okabe_ito()+
  theme(strip.text.x = element_text(size = 6))+
  labs(x = "Timepoints")


df_cor_grid_reg <- df_cor_full %>% 
  group_by(iter_bggm, iter_gvar) %>% 
  # this summarizes prior info etc., which is the same within a simulation condition
  # just a trick to keep it in the df
  summarize(across(everything(),
                   ~mean(.))) %>% 
  pivot_longer(cols = contains("cor"), values_to = "cor", names_to = "mat") %>%
  filter(!is.na(lambda)) %>% 
  mutate(comb = paste0("R: ", rho_prior, ", B: ", beta_prior,
                       ", G: ", gamma_ebic)) %>% 
  # add linetype
  mutate(lty = ifelse(grepl("sel", mat), "select", "nonselect")) %>% 
  ungroup() %>% 
  ggplot(aes(x = n_tp, y = cor, col = mat))+
  geom_line(aes(linetype = lty))+
  theme_bw()+
  facet_grid(dgp~comb)+
  # ggokabeito::scale_color_okabe_ito()+
  theme(strip.text.x = element_text(size = 6))


# Use NULL to create some space between plots
df_cor_grid_sep <- cowplot::plot_grid(
  NULL, df_cor_grid_nonreg, NULL, df_cor_grid_reg,
  labels = c("", "Regularized","", "Non-Regularized"), ncol = 1,
  align = "v",
  rel_heights= c(0.05, 1, 0.05, 1),
  label_x = .01, label_y = 1.05
)

ggsave("df_cor_grid_sep.svg", df_cor_grid_sep, height = 15, width = 18, path = here::here("figures/"), device = "svg")


```



## Average model across simulation fits
Find averaged model across 1000 iterations in one condition. 
```{r}

# BGGM
pcor_list <- lapply(fit_bggm[[70]], function(x)
  return(x$pcor_mu))

pcor_bggm <- apply(simplify2array(pcor_list), 1:2, mean)
diag(pcor_bggm) <- rep(0, 6)
options(scipen = 10)
pcor_bggm

beta_list <- lapply(fit_bggm[[70]], function(x)
  return(x$beta_mu))

apply(simplify2array(beta_list), 1:2, mean)


# gVAR


PCC_gvar_list <- lapply(fit_gvar[[55]], function(x)
  return(x$PCC))

apply(simplify2array(PCC_gvar_list), 1:2, mean)

beta_gvar_list <- lapply(fit_gvar[[55]], function(x)
  return(t(x$beta[,-1])))

apply(simplify2array(beta_gvar_list), 1:2, mean)


```








