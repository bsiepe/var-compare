---
title: "bggm-var-investigation"
author: "Bj√∂rn Siepe"
date: "2022-11-18"
output: html_document
---
In this file, I investigate some of the properties of BGGM var_estimate. 
Does it actually work well? If so, the following should be true.
1. It should perform regularization as it says.
2. It should recover roughly the same estimate as, e.g., graphicalVAR. 


```{r}
source("aux_funs.R")
```



# Test regularization
```{r}
# library("BGGM", lib.loc = "C:/Users/Bjoern/R-dev")


set.seed(2022)
compgraph <- graphicalVAR::randomGVARmodel(Nvar = 6, probKappaEdge = 0.4, probBetaEdge = .2)
dat <- as.data.frame(graphicalVAR::graphicalVARsim(200, beta = compgraph$beta, kappa = compgraph$kappa))
res <- var_estimate(dat,
                          beta_sd = 1)
res2 <- BGGM::var_estimate(dat,
                           beta_sd = 0.1)


# Try the same for rho
res3 <- BGGM::var_estimate(dat,
                          rho_sd = 0.5)
res4 <- BGGM::var_estimate(dat,
                          rho_sd = 0.05)



```

# Compare with GraphicalVAR

For now, just simulate 100 datasets from the same DGP. 
```{r generate-data}
# Storage
l_gvardata <- list()

# Simulation conditions
n_ind <- 200   # number of individuals (so models to create)
n_tp <- 150     # number of timepoints per time series

ncores = parallel::detectCores() - 4
cl = makeCluster(ncores)
registerDoParallel(cl)

l_gvardata <- sim_raw_parallel(dgp = compgraph, n = n_ind, 
                                tp = n_tp, means = 0,
                                standardize = TRUE)

stopCluster(cl)





```

```{r fit-models}
# Model specifics
rho_sd <- 0.5
beta_sd <- 1
seed <- 2022
n_iter <- 5000

l_compres <- list()
ncores = parallel::detectCores() - 4
cl = makeCluster(ncores)
registerDoParallel(cl)

l_compres$bggm <- fit_var_parallel(data = l_gvardata, n = n_ind,
                 rho_prior = rho_sd, beta_prior = beta_sd, seed = seed,
                 iterations = n_iter)

l_compres$gvar <- foreach(i = seq(n_ind), .packages = "graphicalVAR") %dopar% {
  tmp_res <- graphicalVAR(data = l_gvardata[[i]]$data, 
               lambda_beta = 0,
               lambda_kappa = 0, 
               scale = TRUE, 
               gamma = 0)
  
  tmp_res
  
}

stopCluster(cl)


```



Now we can compare the results. What do we look at? Due to no regularization, do not look at true positives/false positives here. 
- difference from data-generating process


TODO: Is it fine not to look at the intercepts? This might be important. 
TODO: Do I need the transpose?
TODO: Add correlations


```{r compare-results}
comp_res <- compare_dgp(true = compgraph, 
                        est_bggm = l_compres$bggm, 
                        est_gvar = l_compres$gvar, n = 200)


```

Plot results: (this should be added as a function later on)
```{r plot-results}



```


Works pretty well for n = 200 and one graph. Default priors seem to be okay, only has convergence issues in some cases.  





# Simulation study

## Data Generation
Just use "truegraph" data from main simulation study for now. 
TODO: Download this from the server. 
```{r}
l_raw <- readRDS(here::here("output/l_raw.RDS"))
l_graphs <- readRDS(here::here("data/l_graphs.RDS"))

# Only truegraph
l_dgp <- list()
l_dgp$graph1 <- lapply(l_raw$graph1, function(x){
  y <- x$truegraph
  y
})
l_dgp$graph2 <- lapply(l_raw$graph2, function(x){
  y <- x$truegraph
  y
})
l_dgp$graph3 <- lapply(l_raw$graph3, function(x){
  y <- x$truegraph
  y
})




```



## Estimation
Estimate both graphicalVAR in default settings as well as BGGM with varying priors.
```{r}
# Priors
dgp_names <- c("graph1", "graph2", "graph3")
dgp <- c(1,2,3)
rho_sd <- c(0.1, 0.3, 0.5)
beta_sd <- c(0.2, 0.5, 1)
n_tp <- c(50, 100, 200, 400, 1000) 
tp_cond <- c(1,2,3,4,5)   # different tp conditions

cond_grid <- expand.grid(dgp = dgp,
                         n_tp = tp_cond,
                         rho_prior = rho_sd, 
                         beta_prior = beta_sd)
n_iter <- 50000
seed <- 2022
set.seed(seed)



# Estimating for each model 
# store BGGM results under "nonselect"
ncores = parallel::detectCores() - 2
cl = makeCluster(ncores)
clusterExport(cl = cl, "summarize_post")
registerDoParallel(cl)
l_res <- list()


# TODO maybe actually use save_files to save results to disc
# Need to adopt such that select works together with summarize_post

for(n in 1:nrow(cond_grid)) {
  dgp_ind <- as.numeric(cond_grid[n, "dgp"])
  tp_ind <- as.numeric(cond_grid[n, "n_tp"])
  r_sd <- as.numeric(cond_grid[n, "rho_prior"])
  b_sd <- as.numeric(cond_grid[n, "beta_prior"])
  print(paste0(nrow(cond_grid)-n, " to go!"))
  l_res[[n]]  <- fit_var_parallel_merged(l_dgp[[dgp_ind]][[tp_ind]],
                          rho_prior = r_sd,
                          beta_prior = b_sd,
                          iterations = n_iter,
                          n = 100,
                          nds = 100,
                          seed = seed,
                          summarize_post = TRUE,
                          cred_int = c(0.9, 0.95, 0.99),
                          pruneresults = FALSE,
                          save_files = FALSE,
                          multigroup = FALSE,
                          select = TRUE)
    

  
}
stopCluster(cl)

# saveRDS(l_res, here::here("output/bggm-var-sim-res.Rds"))
l_res_bggm <- readRDS(here::here("output/bggm-var-sim-res.Rds"))


# Attach the simulation conditions
for(m in 1:nrow(cond_grid)){
  for(i in 1:length(l_res_bggm[[m]])){
    l_res_bggm[[m]][[i]]$sim_cond <- cond_grid[m,]
  }
}

```
### Fit graphicalVAR
```{r}
# Conditions of varying sparsity
dgp_names <- c("graph1", "graph2", "graph3")
dgp <- c(1,2,3)
gamma_ebic <- c(0, 0.5)      # EBIC hyperparamater
lambda <- c(NA, 0)
n_tp <- c(50, 100, 200, 400, 1000) 
tp_cond <- c(1,2,3,4,5)   # different tp conditions

cond_grid_gvar <- expand.grid(dgp = dgp,
                         n_tp = tp_cond,
                         gamma_ebic = gamma_ebic,
                         lambda = lambda)




ncores = parallel::detectCores() - 2
cl = makeCluster(ncores)
clusterExport(cl = cl, "fit_graphicalvar_parallel")
registerDoParallel(cl)
l_res_gvar <- list()
time_before_gvar <- Sys.time()
for(n in 1:nrow(cond_grid)) {
  dgp_ind <- as.numeric(cond_grid_gvar[n, "dgp"])
  tp_ind <- as.numeric(cond_grid_gvar[n, "n_tp"])
  gamma_ebic <- as.numeric(cond_grid_gvar[n, "gamma_ebic"])
  lambda <- as.numeric(cond_grid_gvar[n, "lambda"])
  print(paste0(nrow(cond_grid_gvar)-n, " to go!"))
  
  # unregularized
  if(!is.na(lambda)){
   l_res_gvar[[n]]  <- fit_graphicalvar_parallel(l_dgp[[dgp_ind]][[tp_ind]],
                                                  n = 100,
                                                  gamma = gamma_ebic,
                                                  nLambda = 50, 
                                                  pruneresults = TRUE, 
                                                  lambda_beta = lambda,
                                                  lambda_kappa = lambda)
                            
  }
  # regularized
  if(is.na(lambda)){
   l_res_gvar[[n]]  <- fit_graphicalvar_parallel(l_dgp[[dgp_ind]][[tp_ind]],
                                                 n = 100,
                                                 gamma = gamma_ebic,
                                                 nLambda = 50, 
                                                 pruneresults = TRUE)
    
  }
    

  
}
stopCluster(cl)

time_after_gvar <- Sys.time() - time_before_gvar
# saveRDS(l_res_gvar, here::here("output/graphicalvar-sim-res.Rds"))
l_res_gvar <- readRDS(here::here("output/graphicalvar-sim-res.Rds"))


 
# Attach the simulation conditions
for(m in 1:nrow(cond_grid_gvar)){
  for(i in 1:length(l_res_gvar[[m]])){
    l_res_gvar[[m]][[i]]$sim_cond <- cond_grid_gvar[m,]
  }
}
    








```




## Evaluation
Evaluate both with and without graph selection.

Evaluation function
```{r}
# TODO be very careful about transposing beta here or not!!!!

```




### Evaluate BGGM
```{r}


l_eval_bggm <- lapply(l_res_bggm, function(x){
  res <- lapply(x, eval_bggm)
  return(res)
})

# Convert to dataframe
# df_test <- purrr::map_depth(test_eval, 3, ~if (is.data.frame(.)) as_tibble(.) else (.))
df_eval_bggm <- purrr::flatten(l_eval_bggm)
df_eval_bggm <- dplyr::bind_rows(df_eval_bggm)
names(df_eval_bggm) <- gsub("ci", "", names(df_eval_bggm))
names(df_eval_bggm) <- gsub("\\$", "", names(df_eval_bggm))

# Pivot CIs wider
df_eval_bggm_wide <- df_eval_bggm %>% 
  tidyr::unpack(cols = ci) %>% 
  pivot_wider(names_from = ci, values_from = c(sum_cover_beta, sum_cover_pcor,
                                               width_beta, width_pcor))


plot_eval_bggm <- df_eval_bggm_wide %>% 
  group_by(dgp_ind, tp_ind, rho_prior, beta_prior) %>% 
  # convert coverage into proportion
  mutate(across(contains("sum_cover_beta"),
                ~ ./36)) %>% 
  # divide by number of unique off-diagonal elements
  mutate(across(contains("sum_cover_pcor"),
                ~ ./15)) %>% 
  summarize(across(c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                   bias_beta_sel,bias_pcor_sel, spec_beta, spec_pcor,
                   sens_beta, sens_pcor, contains("sum_cover")), 
                   ~mean(.))) %>% 
  pivot_longer(cols = c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                   bias_beta_sel, bias_pcor_sel, spec_beta, spec_pcor,
                   sens_beta, sens_pcor, contains("sum_cover")), names_to = "stat", 
               values_to = "value") %>% 
  mutate(prior_comb = paste0("rho = ", rho_prior, ", beta = ", beta_prior)) %>% 
  ggplot(aes(x = tp_ind, y = value, col = prior_comb)) + 
  facet_grid(dgp_ind ~ stat) + 
  geom_line() + 
  theme_bw()+
  ggokabeito::scale_color_okabe_ito()

ggsave(here::here("figures/plot_eval_bggm.svg"), plot_eval_bggm, device = "svg", width = 20, height = 9)  

```

### Evaluate GVAR
```{r}
l_eval_gvar <- lapply(l_res_gvar, function(x){
  res <- lapply(x, eval_gvar)
  return(res)
})

l_eval_gvar <- list()
for(i in 1:nrow(cond_grid_gvar)){
  l_eval_gvar[[i]] <- lapply(l_res_gvar[[i]], eval_gvar)
}
# TODO check why there are issues with the standard deviation of something

# Convert to dataframe
df_eval_gvar <- purrr::flatten(l_eval_gvar)
df_eval_gvar <- dplyr::bind_rows(df_eval_gvar)



```

Plot results

```{r}
plot_eval_gvar <- df_eval_gvar %>% 
  mutate(lambda = as.character(lambda)) %>% 
  mutate(lambda = tidyr::replace_na(lambda, "default")) %>% 
  group_by(dgp_ind, tp_ind, ebic, lambda) %>% 
  summarize(across(c(bias_beta, bias_pcor, cor_beta, cor_pcor,
                     spec_beta, spec_pcor,
                     sens_beta, sens_pcor),
                   ~mean(.))) %>% 
  pivot_longer(cols = (c(bias_beta, bias_pcor, cor_beta, cor_pcor, 
                         spec_beta, spec_pcor,
                         sens_beta, sens_pcor)), 
               names_to = "stat", values_to = "value") %>% 
   mutate(ebic_lambda_comb = paste0("Gamma: ", ebic, ", Lambda = ", lambda)) %>% 
  ggplot(aes(x = tp_ind, y = value, col = ebic_lambda_comb))+
  geom_line()+
  facet_grid(dgp_ind ~ stat) + 
  theme_bw()+
  ggokabeito::scale_colour_okabe_ito()

ggsave(here::here("figures/plot_eval_gvar.svg"), plot_eval_gvar, device = "svg", width = 16, height = 9)  

```




## Correlate BGGM and graphicalVAR







