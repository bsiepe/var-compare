---
title: "var-reliability-estimation"
author: "Bj√∂rn Siepe"
date: "2022-12-02"
output: html_document
---

# Reliability estimation from posterior samples

Compare variance within a person (across posterior samples) to variation across individuals


```{r data-simulation}
# Use one ground-truth model and simulate from it (assuming homogeneity)
set.seed(2022)
graph <- randomGVARmodel(Nvar = 6, probKappaEdge = 0.1, probBetaEdge = .5)

# simulate 50 data sets
l_sims <- list()
for(i in 1:250){
  l_sims[[i]] <- graphicalVAR::graphicalVARsim(nTime = 200,
                                          beta = graph$beta,
                                          kappa = graph$kappa)
}

```

Now we fit the bayesian VAR model again.

```{r}
l_est <- list()
l_sims <- lapply(l_sims, as.data.frame)
for(i in 1:250){
  l_est[[i]] <- try(BGGM::var_estimate(l_sims[[i]],
                                   seed = 2022,
                                   progress = FALSE))
}


```

Obtain variance-covariance matrices for posterior sampling distributions: I still have to understand what the order means, so what is lagged on what.

```{r}
ncores = parallel::detectCores() - 4
cl = makeCluster(ncores)
registerDoParallel(cl)
source("aux_funs.R")
l_cov <- foreach(i = 1:250) %dopar% {
  covres <- try(f_postcov(l_est[[i]])) 
  covres
}


stopCluster(cl)
```

Save mean betas and covariances for each individual:

```{r}
l_beta <- list()
for(i in 1:250){
  beta <- melt(as.matrix(l_est[[i]]$beta_mu))
  beta$est <- paste(beta$Var1, beta$Var2, sep = "_")
  beta$id <- i
  beta <- subset(beta, select = -c(Var1, Var2))
  l_beta[[i]] <- beta
}
df_beta <- do.call(rbind, l_beta)

# Variance-covariance in long format
l_cov_long <- list()
for(i in 1:250){
  cov <- melt(as.matrix(l_cov[[i]]))
  cov$cov <- paste(cov$Var1, cov$Var2, sep = "_")
  cov$id <- i
  cov <- subset(cov, select = -c(Var1, Var2))
  l_cov_long[[i]] <- cov
}
df_cov <- do.call(rbind, l_cov_long)

# Only use variances for now
pars <- unique(df_beta$est)
variance <- paste(pars, pars, sep = "_")  # covariance of parameters with themselves, so variances

# filter for variance parameters, rename to remove redundancy
df_var <- df_cov %>% 
  filter(cov %in% variance) %>% 
  mutate(cov = stringr::str_sub(cov, 1, 8))
  

```



Compute reliability as within deviation over between deviation:

```{r}
# variance of betas across individuals
var_bw <- df_beta %>% 
  group_by(est) %>% 
  summarize(var_beta = var(value)) %>% 
  summarize(mean_var_beta = mean(var_beta)) %>% 
  pull(mean_var_beta)

# mean variance of betas within individuals
var_wi <- df_var %>% 
  group_by(cov) %>% 
  summarize(var_cov = mean(value)) %>% 
  summarize(mean_var_cov = mean(var_cov)) %>% 
  pull(mean_var_cov)

rel <- (var_bw-var_wi)/(var_bw)
# This is a bad result. A large part of the variance is attributed
# to the between-person level, although it should just be sampling noise
var_bw/var_wi

```


Other idea:

-means per var per person, variance between means between persons
-draw 10 values per person, compute SD

for each person: descriptive mean and sampling error, true mean should be the same
- then we can test if the formula works well

simulate one regression per person
- 2 predictors, but predictors are multicollinear
- this affects standard errors, maybe this formula does not work here
- 
show Ricci stuff

